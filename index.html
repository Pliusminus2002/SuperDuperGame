<!DOCTYPE html>
<html lang="lt">
<head>
  <meta charset="UTF-8" />
  <title>Super Duper game</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><text x='0' y='14'>üéÆ</text></svg>">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      user-select: none;
    }
    canvas#game {
      display: block;
    }
    canvas#minimap {
      position: fixed;
      right: 16px;
      bottom: 16px;
      width: 180px;
      height: 180px;
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid rgba(255, 255, 255, 0.4);
      pointer-events: none;
    }
    #letter-overlay {
  position: fixed;
  inset: 0;
  display: grid;
  place-items: center;
  background: rgba(0,0,0,0.65);
  backdrop-filter: blur(2px);
  z-index: 10000;
  pointer-events: auto;
}

.letter-hidden { display: none !important; }

.letter-paper {
  width: min(860px, 92vw);
  max-height: min(78vh, 720px);
  overflow: auto;
  padding: 28px 26px 22px;
  border-radius: 18px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.6);
  border: 1px solid rgba(60, 35, 10, 0.35);

  /* ‚Äúpergamentas‚Äù */
  background:
    radial-gradient(1200px 500px at 20% 10%, rgba(255,255,255,0.22), transparent 60%),
    radial-gradient(900px 420px at 80% 30%, rgba(0,0,0,0.10), transparent 55%),
    linear-gradient(180deg, #f2e1b8, #e7cfa0 55%, #ddc08f);
}

.letter-title {
  font-size: 26px;
  letter-spacing: 0.3px;
  margin-bottom: 12px;
  color: #3a220f;
  text-shadow: 0 1px 0 rgba(255,255,255,0.35);
}

.letter-body {
  font-size: 18px;
  line-height: 1.55;
  color: #2a170c;
  white-space: pre-wrap;
}

.letter-hint{
  margin-top: 14px;
  font-size: 13px;
  color: rgba(40, 20, 10, 0.6);
  text-align: right;
  user-select: none;
}

/* AIM mini-game taikiniai */
.aim-target {
  animation: aimPulse 0.6s infinite alternate;
}

@keyframes aimPulse {
  from {
    transform: scale(1);
    opacity: 0.6;
  }
  to {
    transform: scale(1.2);
    opacity: 1;
  }
}

    /* dialogo burbuliukas ir mini-game ≈æinutƒó */
    .dialog-bubble {
      position: fixed;
      left: 50%;
      bottom: 12%;
      transform: translateX(-50%);
      max-width: 420px;
      padding: 12px 16px;
      border-radius: 14px;
      background: rgba(15, 20, 35, 0.95);
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-size: 16px;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: none;
      z-index: 10;
    }
    .dialog-bubble #dialogText {
      margin-bottom: 8px;
    }
    .dialog-bubble #dialogOptions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .dialog-bubble #dialogOptions button {
      flex: 1;
      padding: 6px 10px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: rgba(80, 140, 255, 0.9);
      color: #fff;
      font-weight: 600;
      font-size: 14px;
    }
    .dialog-bubble #dialogOptions button:hover {
      background: rgba(120, 170, 255, 1);
    }
    .dialog-bubble.small {
      bottom: 5%;
      font-size: 14px;
      max-width: 320px;
      padding: 6px 10px;
    }
  /* üé¨ THE END overlay */
#end-overlay{
  position: fixed;
  inset: 0;
  background: #000;
  opacity: 0;
  display: none;
  z-index: 20000;
  pointer-events: none;
}

#end-text{
  position: absolute;
  inset: 0;
  display: grid;
  place-items: center;
  text-align: center;
  font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
  letter-spacing: 2px;
}

#end-text .end-line1{
  font-size: clamp(34px, 6vw, 72px);
  font-weight: 800;
  color: #fff;
  margin-bottom: 12px;
}

#end-text .end-line2{
  font-size: clamp(22px, 4vw, 54px);
  font-weight: 800;
  color: #fff;
}

#end-text .end-heart{
  color: #ff2b6a;
}
  
  </style>
</head>
<body>

  <canvas id="game"></canvas>
  <canvas id="minimap"></canvas>
  <!-- üé¨ THE END overlay -->
<div id="end-overlay" style="display:none;">
  <div id="end-text">
    <div class="end-line1">THE END,</div>
    <div class="end-line2">MY LOVE <span class="end-heart">‚ù§Ô∏è</span></div>
  </div>
</div>

<div id="letter-overlay" class="letter-hidden">
  <div class="letter-paper">
    <div class="letter-title" id="letter-title"></div>
    <div class="letter-body" id="letter-body"></div>
    <div class="letter-hint">[Enter / Esc / click]</div>
  </div>
</div>

  <!-- dialogas NPC A/B/C klausimams -->
  <div id="dialogContainer" class="dialog-bubble">
    <div id="dialogText"></div>
    <div id="dialogOptions">
      <button data-choice="A">A</button>
      <button data-choice="B">B</button>
      <button data-choice="C">C</button>
    </div>
  </div>

  <!-- mini-game ≈æinutƒó / instrukcijos -->
  <div id="minigameMessage" class="dialog-bubble small">Mini ≈æaidimo vieta</div>
  <!-- NPC kalbƒójimo burbuliukas (princesƒó / cutscenes) -->
<div id="npcSpeech" class="dialog-bubble" style="display:none; pointer-events:none;"></div>

  <!-- 1 mini-game: AIM (CS:GO tipo) -->
  <div id="aimGameOverlay" class="dialog-bubble small" style="display:none; pointer-events:auto;">
    <div id="aimGameInfo"></div>
    <div id="aimGameTargetsContainer"
         style="position:relative; width:260px; height:180px; margin-top:8px;
                border-radius:8px; background:#050910; overflow:hidden;">
    </div>
  </div>

  <!-- 2 mini-game: KLAUSIM≈≤ TESTAS (apie merginƒÖ) -->
  <div id="quizOverlay" class="dialog-bubble" style="display:none; pointer-events:auto;">
    <div id="quizQuestion"></div>
    <div id="quizProgress" style="font-size:13px; opacity:0.8; margin-top:4px;"></div>
    <div id="quizOptions" style="display:flex; flex-direction:column; gap:6px; margin-top:10px;"></div>
  </div>

  <!-- 3 mini-game: KORT≈≤ POROS -->
  <div id="cardsOverlay" class="dialog-bubble" style="display:none; pointer-events:auto;">
    <div id="cardsInfo"></div>
    <div id="cardsGrid"
         style="display:grid; grid-template-columns:repeat(4,1fr); gap:6px; margin-top:10px;">
    </div>
  </div>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>

  <script type="module">
    console.log("VERSION TEST: A1");
    import * as THREE from 'three';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
    import { FBXLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/FBXLoader.js';
let letterOpen = false;
let letterTypingTimer = null;

function openLetter({ title = "Lai≈°kas", body = "", typeSpeed = 18 } = {}) {
  const overlay = document.getElementById("letter-overlay");
  const tEl = document.getElementById("letter-title");
  const bEl = document.getElementById("letter-body");

  // stop senƒÖ typing
  if (letterTypingTimer) clearInterval(letterTypingTimer);
  letterTypingTimer = null;

  tEl.textContent = title;
  bEl.textContent = "";
  overlay.classList.remove("letter-hidden");
  letterOpen = true;
controlsLocked = true;

// sustabdom judƒójimƒÖ i≈°kart
if (typeof keys !== 'undefined') {
  keys.forward = keys.back = keys.left = keys.right = keys.shift = false;
}

// sustabdom animacijƒÖ ƒØ idle (jei yra)
if (typeof fadeToAction === 'function') {
  fadeToAction('idle', 0.1);
}

  // typing efektas
  let i = 0;
  letterTypingTimer = setInterval(() => {
    bEl.textContent += body[i] ?? "";
    i++;
    if (i >= body.length) {
      clearInterval(letterTypingTimer);
      letterTypingTimer = null;
    }
  }, typeSpeed);

  // jei turi savo ≈æaidime input lock ‚Äî ƒçia ƒØstatysi:
  // controlsEnabled = false;
}

function closeLetter() {
  const overlay = document.getElementById("letter-overlay");
  if (letterTypingTimer) clearInterval(letterTypingTimer);
  letterTypingTimer = null;
  overlay.classList.add("letter-hidden");
  letterOpen = false;

  // ‚ùå NEBEATRAKINAM ƒåIA VISADA
  // controlsLocked = false;

  // jei buvo paprastas lai≈°kas (ne cutscene), leisk judƒót:
  if (!princessScene && !minigameInProgress) {
    controlsLocked = false;
  }

  if (princessWaitingForEnter) princessWaitingForEnter = false;
}


document.addEventListener("keydown", (e) => {
  if (!letterOpen) return;
  if (e.key === "Enter" || e.key === "Escape") closeLetter();
});

document.getElementById("letter-overlay").addEventListener("click", () => {
  if (letterOpen) closeLetter();
});

    // ---------- BENDRI KINTAMIEJI ----------
    let scene, camera, renderer;
    let controlsLocked = false;

    const clock = new THREE.Clock();

    let ninja = null;
    let mixer = null;
    
    const actions = {};
    
    let activeAction = null;
    const BREAKDANCE_YAW_FIX = Math.PI / 2; // jei bus blogai ‚Äì pakeisim ƒØ -Math.PI/2 arba Math.PI
    const BREAKDANCE_ROLL_FIX = -Math.PI / 2; // jei bus ne ta pusƒó ‚Äî pakeisk ƒØ +Math.PI/2

let breakdanceGroundOffset = null;

// ---------- AUDIO FAILAI ----------
const audio = {
  catPsst: new Audio('./audio/cat psst-242776.mp3'),
  catMeow: new Audio('./audio/cat moew.mp3'),

  annieTalk: new Audio('./audio/Annie-babble-45052.mp3'),
  femaleTalk: new Audio('./audio/Female-talking-78916.mp3'),
  laraTalk: new Audio('./audio/Lara-talking-47375.mp3'),
  princessTalk: new Audio('./audio/Princess-talk-41825.mp3'),

  deathSound: new Audio('./audio/death-sound-effect-331435.mp3'),
  respawnKiss: new Audio('./audio/respawn.long-kiss-242243.mp3'),
};
// üéµ BACKGROUND MUSIC
const music = {
  forest:    new Audio('./audio/mystery.mp3'),      // üå≤ mi≈°kas
  castle:    new Audio('./audio/liquid.mp3'),       // üè∞ pilis
  gameRoom:  new Audio('./audio/lana.mp3'),         // üéÆ mini-games
  princess:  new Audio('./audio/4AM In NY.mp3'),  
    // üëë princesƒó
  breakdance:new Audio('./audio/breakdance.mp3')    // üíÉ finalas
};
music.forest._startAt = 30;
music.princess._startAt = 30;
music.castle._startAt = 12;


// loop + pradinis garsas
Object.values(music).forEach(m => {
  m.loop = true;
  m.volume = 0.5;
});

// breakdance turi NE-loopintis
music.breakdance.loop = false;

// üîä GARSO BALANSAS
music.forest.volume = 0.5;
music.castle.volume = 0.45;
music.gameRoom.volume = 0.55;
music.princess.volume = 0.4;
music.breakdance.volume = 0.6;

audio.deathSound.volume = 1.0;
audio.respawnKiss.volume = 1.0;
audio.catPsst.volume = 1.0;
audio.catMeow.volume = 0.9;


function playAudio(sound, volume = 1) {
  if (!sound) return;
    const v = Math.min(1, Math.max(0, volume));
  sound.volume = v;
  sound.currentTime = 0;
  sound.play().catch(() => {});
  
}
function playNpcVoice(info) {
  if (!info) return;
  if (info.name === 'Annie') {
    playAudio(audio.annieTalk, 1.0);
  } else if (info.name === 'Female') {
    playAudio(audio.femaleTalk, 1);
  } else if (info.name === 'Lara') {
    playAudio(audio.laraTalk, 1);
  }
}

function stopNpcVoice(info) {
  if (!info) return;
  if (info.name === 'Annie') {
    audio.annieTalk.pause();
    audio.annieTalk.currentTime = 0;
  } else if (info.name === 'Female') {
    audio.femaleTalk.pause();
    audio.femaleTalk.currentTime = 0;
  } else if (info.name === 'Lara') {
    audio.laraTalk.pause();
    audio.laraTalk.currentTime = 0;
  }
}

// kad garsai galƒót≈≥ groti be limit≈≥ ir nestringt≈≥
Object.values(audio).forEach(a => {
  a.preload = 'auto';
});
// üîì Leid≈æia visiems audio groti po pirmo ≈æaidƒójo paspaudimo
window.addEventListener("pointerdown", () => {
  Object.values(audio).forEach(a => {
    a.muted = false;
  });
}, { once: true });
let currentMusic = null;
let musicOverride = null;
let lastZone = null;

let audioUnlocked = false;   // <-- PRIDƒñTA
function unlockAudioOnce() {
  if (audioUnlocked) return;
  audioUnlocked = true;

  // atrakinti visus audio (fx + muzika)
  Object.values(audio).forEach(a => {
    a.muted = false;
    a.preload = 'auto';
  });

  Object.values(music).forEach(m => {
    m.muted = false;
    m.preload = 'auto';
  });
}

function fadeAudioTo(aud, targetVol, duration = 0.7) {
  if (!aud) return;
  const startVol = aud.volume;
  const t0 = performance.now();

  const step = () => {
    const t = (performance.now() - t0) / (duration * 1000);
    if (t >= 1) { aud.volume = targetVol; return; }
    aud.volume = startVol + (targetVol - startVol) * t;
    requestAnimationFrame(step);
  };
  requestAnimationFrame(step);
}

function playMusicCrossfade(next, targetVol = 0.38, fadeSec = 0.7) {
  if (!next) return;

  // i≈°fade‚Äôinam senƒÖ
  if (currentMusic && currentMusic !== next) {
    const prev = currentMusic;
    fadeAudioTo(prev, 0.0, fadeSec);
    setTimeout(() => {
      prev.pause();
      try { prev.currentTime = 0; } catch(e) {}
    }, fadeSec * 1000 + 30);
  }

  // u≈æfade‚Äôinam naujƒÖ
  currentMusic = next;

  // ‚úÖ start offset (pvz +30s)
  const startAt = currentMusic._startAt || 0;

  if (currentMusic.readyState >= 1) {
    try { currentMusic.currentTime = startAt; } catch(e) {}
  } else {
    currentMusic.addEventListener('loadedmetadata', () => {
      try { currentMusic.currentTime = startAt; } catch(e) {}
    }, { once: true });
  }

  currentMusic.volume = 0.0;
  currentMusic.play().catch(() => {});
  fadeAudioTo(currentMusic, targetVol, fadeSec);
}
function isOnBridgeXZ(x, z) {
  const onSegment1 =
    z >= BRIDGE_SEG1_Z - BRIDGE_SEG_DEPTH / 2 &&
    z <= BRIDGE_SEG1_Z + BRIDGE_SEG_DEPTH / 2;

  const onSegment2 =
    z >= BRIDGE_SEG2_Z - BRIDGE_SEG_DEPTH / 2 &&
    z <= BRIDGE_SEG2_Z + BRIDGE_SEG_DEPTH / 2;

  const onSegment3 =
    z >= BRIDGE_SEG3_Z - BRIDGE_SEG_DEPTH / 2 &&
    z <= BRIDGE_SEG3_Z + BRIDGE_SEG_DEPTH / 2;

  const onAnySegment = onSegment1 || onSegment2 || onSegment3;
  const onBridgeX = Math.abs(x - BRIDGE_X) <= BRIDGE_SAFE_HALF_WIDTH;

  return onAnySegment && onBridgeX;
}

function getZone() {
  if (!ninja) return 'forest';

  const x = ninja.position.x;
  const z = ninja.position.z;

  // 0) jei ant tilto ‚Äî visada mi≈°ko muzika
  if (isOnBridgeXZ(x, z)) return 'forest';

  // 1) princesƒós bok≈°tas
  {
    const dx = x - PRINCESS_TOWER_CENTER.x;
    const dz = z - PRINCESS_TOWER_CENTER.y;
    if (dx*dx + dz*dz < (PRINCESS_TOWER_RADIUS - 1.5) ** 2) return 'princess';
  }

  // 2) mini-games bok≈°to kambarys
  if (isHeroInTowerRoom()) return 'gameRoom';

  // 3) pilies sala (apskritimas)
  {
    const dx = x - goalPos.x;
    const dz = z - goalPos.z;
    if (dx*dx + dz*dz < (CASTLE_RADIUS - 1.0) ** 2) return 'castle';
  }

  // 4) kita ‚Äî mi≈°kas
  return 'forest';
}

function updateZoneMusic() {
  if (musicOverride) return;      // pvz. breakdance metu ‚Äì zonos nekaitaliojam
  if (!audioUnlocked) return;

  const zone = getZone();

  // ‚úÖ jei zona ta pati, bet muzika dingo arba pauzƒó ‚Äì pramu≈°am
  if (zone === lastZone) {
    if (!currentMusic) {
      if (zone === 'forest')   playMusicCrossfade(music.forest,   0.50, 0.20);
      if (zone === 'castle')   playMusicCrossfade(music.castle,   0.28, 0.8);
      if (zone === 'gameRoom') playMusicCrossfade(music.gameRoom, 0.55, 0.8);
      if (zone === 'princess') playMusicCrossfade(music.princess, 0.32, 0.20);
    } else if (currentMusic.paused) {
      currentMusic.play().catch(() => {});
    }
    return;
  }

  // zona pasikeitƒó
  lastZone = zone;

  if (zone === 'forest')   playMusicCrossfade(music.forest,   0.50, 0.20);
  if (zone === 'castle')   playMusicCrossfade(music.castle,   0.28, 0.8);
  if (zone === 'gameRoom') playMusicCrossfade(music.gameRoom, 0.55, 0.8);
  if (zone === 'princess') playMusicCrossfade(music.princess, 0.32, 0.20);
}


window.addEventListener('click', () => {
  unlockAudioOnce();
  lastZone = null;
  updateZoneMusic();
}, { once: true });

let hipsBone = null;
let hipsSavedRot = null;
let footBones = []; // Left/Right foot/toe bones
const _tmpV3 = new THREE.Vector3();


    // D≈æiugas
    let dziugas = null;
    let dziugasFound = false;
    let dziugasFollowSpeed = 10;

    // Katinas
    let cat = null;
    let catFollowing = false;
    let catFollowSpeed = 8;
    const CAT_ROT_OFFSET = -Math.PI / 2; // katinas ≈æi≈´ri tiesiai
    // Princesƒó
    let princess = null;
    let princessMixer = null;
    let princessWaitingForEnter = false;
    let princessApproach = false;
let princessTalked = false;
let princessApproachAllowed = false;
let princessScene = null;         // 'afterMinigames' | 'afterBreakdance' | null
let princessSceneStarted = false; // kad nepradƒót≈≥ 100 kart≈≥
let princessSceneText = '';
let princessFrozen = false;
let princessStopPos = null;
let princessStartPos = null; // <- taip
 // ‚úÖ ƒçia ƒØsimins kur ji turi sustoti
// --- princesƒós "mar≈°rutas" po teleport (ateina -> kra≈°tas -> atgal -> kalba)
let princessRoutePhase = 'none'; // 'toNinja' | 'toEdge' | 'backToNinja' | 'done'
let princessEdgeTarget = new THREE.Vector3();
let princessEdgePos = null;    // fiksuotas kra≈°to ta≈°kas (kur ji stovi prad≈æioj)
let princessCenterPos = null;  // bok≈°to centras


const PRINCESS_ROT_OFFSET = 0; // jei bus atbulai ‚Äì pakeisk ƒØ Math.PI

    const princessActions = {};

    // Pilis
    let castleCompleted = false;
    let castleGate = null;
    let castleGateOpen = false;

    // Klavi≈°ai
    const keys = { forward:false, back:false, left:false, right:false, shift:false };

    // ≈†uolis
    let velY = 0;
    let onGround = true;
    let isJumping = false;
    const GRAVITY = 25;
    const JUMP_FORCE = 9;
      let isRespawning = false;
let deathLetterShown = false;


    // Med≈æiai kolizijai + minimapui
    const treesData = [];
    const HERO_RADIUS = 0.5;

    // Minimapas
    const minimapCanvas = document.getElementById('minimap');
    const mapCtx = minimapCanvas.getContext('2d');
    minimapCanvas.width = 180;
    minimapCanvas.height = 180;
    const MAP_VIEW_RADIUS = 140;

    // Salos / pozicijos
    const FOREST_RADIUS = 55;
    const CASTLE_RADIUS = 40;

    const FOREST_CENTER = new THREE.Vector2(0, 0);
    const goalPos = { x: 0, z: -130 }; // pilies sala

    // Atskiras bok≈°to kambarys (3 durys)
    const TOWER_ROOM_CENTER = new THREE.Vector2(500, 0);
    const TOWER_ROOM_RADIUS = 20;

    // Princesƒós bok≈°tas
    const PRINCESS_TOWER_CENTER = new THREE.Vector2(530, 0);
    const PRINCESS_TOWER_RADIUS = 12;

    // Pilies geometrija
    const CASTLE_YARD_HALF_X = 24;
    const CASTLE_YARD_HALF_Z = 30;
    const CASTLE_WALL_THICKNESS = 1.2;
    const CASTLE_GATE_WIDTH = 4;
    const CASTLE_TOWER_HALF = 7;

    // Tiltas
    const BRIDGE_WIDTH = 2.4;
    const BRIDGE_PLANK_HEIGHT = 0.5;
    const BRIDGE_X = 0;
    const BRIDGE_SEG_DEPTH = 11;
    const BRIDGE_GAP = 2.0;
    const BRIDGE_EXTRA_START = 3;

    const BRIDGE_SEG1_Z = -60 + BRIDGE_EXTRA_START;
    const BRIDGE_SEG2_Z = BRIDGE_SEG1_Z - BRIDGE_SEG_DEPTH - BRIDGE_GAP;
    const BRIDGE_SEG3_Z = BRIDGE_SEG2_Z - BRIDGE_SEG_DEPTH - BRIDGE_GAP;

    const BRIDGE_SAFE_HALF_WIDTH = BRIDGE_WIDTH * 0.5;
    const bridgeSegments = [];

    // Kamera
    let camYawOffset = 0;
    let camPitch = 0.25;
    let isMouseDown = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    // NPC (merginos) + dialogai
    let npcLoader = null;
    const npcInfos = []; // { name, mesh, mixer, idleAction, talkAction, walkAction, startPos, state }

    let npcDialogStage = 0; // 0 ‚Äì nepradƒóta, 4 ‚Äì baigta
    let npcDialogTimer = 0;
    let npcDialogSequenceStarted = false;
    let npcWaitingForAnswer = false;
    let npcCurrentIndex = -1;

    const npcQuestions = [
  {
    text: ' 1 klausimas:Koks mylimosios mƒógstamiausias met≈≥ laikas?',
    options: [
      'A)Vasara',
      'B) Ruduo',
      'C) ≈Ωiema',
    ],
    correct: 'C'
  },
  {
    text: '2 klausimas: Kas mylimƒÖjƒÖ greiƒçiausiai prad≈æiugina?',
    options: [
      'A) Skani kava',
      'B) Netikƒótas komplimentas',
      'C) ≈†iltas apkabinimas'
    ],
    correct: 'B'
  },
  {
    text: '3 klausimas: Kuria love-language mylimoji kalba stipriausiai?',
    options: [
      'A) Words of affirmation (≈æod≈æiai)',
      'B) Physical touch (prisilietimai)',
      'C) Quality time (laikas)'
    ],
    correct: 'C'
  }
];
    // Durys bok≈°to kambaryje
       const doorObjects = [];
    let currentDoorIndex = -1;
    const miniGamesCompleted = [false, false, false];

    // Mini ≈æaidim≈≥ logika (bendri)
    let activeMinigameDoor = null;  // 0,1,2 arba null
    let minigameInProgress = false;
    let minigameTimer = 0;          // sekundƒós (skaiƒçiuojam per updateMinigameTimer)
    let minigameFailed = false;

    // 1 mini-game: AIM (taikiniai)
    let aimScore = 0;
    let aimSpawnIntervalId = null;

    // 2 mini-game: KLAUSIM≈≤ TESTAS (apie merginƒÖ)
   const quizQuestions = [
  {
    text: 'Kas tavo merginƒÖ labiausiai ‚Äûi≈°veda i≈° rikiuotƒós‚Äú kai tu taip darai?',
    options: [
      'A) vie≈°oj vietoj palieti vulgariai',
      'B) ≈†velniai palieƒçia',
      'C) Pa≈°nib≈æda kƒÖ nors mielo'
    ],
    correct: 0 // A
  },
  {
    text: 'Kada a≈° b≈´nu pati mieliausia tau?',
    options: [
      'A) Kai esu pavargusi',
      'B) Kai bandau paslƒópti ≈°ypsenƒÖ',
      'C) Kai mane ka≈ækas sugƒódina komplimentu'
    ],
    correct: 1 // B
  },
  {
    text: 'Kuris komplimentas man labiausiai patikt≈≥ i≈° tavƒôs?',
    options: [
      'A) ‚ÄûGra≈æiai atrodai‚Äú',
      'B) ‚ÄûTu mane ≈æavi labiau nei turƒótum‚Äú',
      'C) ‚ÄûTavo energija labai traukia‚Äú'
    ],
    correct: 1 // B
  },
  {
    text: 'KƒÖ a≈° labiausiai mƒógstu veikti laisvu laiku?',
    options: [
      'A) Klausyt muzikos',
      'B) ≈Ωi≈´rƒóti filmus',
      'C) B≈´ti lauke / pasivaik≈°ƒçioti'
    ],
    correct: 0 // A
  },
  {
    text: 'Jei turƒóƒçiau rinktis pasimatymo veiklƒÖ, kƒÖ imƒçiau?',
    options: [
      'A) Va≈æiuot ma≈°ina ir klausyt muzikos',
      'B) Kartu gaminti maistƒÖ',
      'C) Imti spontani≈°kƒÖ mini crazy nuotykƒØ'
    ],
    correct: 2 // C
  },
  {
    text: 'Kur a≈° labiau norƒóƒçiau nuvykti savaitgalƒØ?',
    options: [
      'A) ƒÆ miestƒÖ su daug ≈°urmulio',
      'B) ƒÆ ramesnƒô gamtos vietƒÖ',
      'C) ƒÆ kino teatrƒÖ'
    ],
    correct: 1 // B
  },
  {
    text: 'KƒÖ renkuosi, kai noriu atsipalaiduoti?',
    options: [
      'A) Kar≈°tƒÖ du≈°ƒÖ/vonƒô',
      'B) FilmƒÖ ir u≈æklotƒÖ',
      'C) MuzikƒÖ su ausinƒómis'
    ],
    correct: 1 // B
  },
  {
    text: 'Kas mano mƒógstamiausia gƒórimo r≈´≈°is?',
    options: [
      'A) Kava',
      'B) Arbata',
      'C) Limonadas'
    ],
    correct: 2 // C
  },
  {
    text: 'Koks mano vibe da≈æniausiai?',
    options: [
      'A) Nervinga',
      'B) ≈Ωaisminga',
      'C) TruputƒØ paslaptinga'
    ],
    correct: 0 // A
  },
  {
    text: 'KƒÖ da≈æniausiai renkuosi ryte?',
    options: [
      'A) Nieko ‚Äî tiesiog skubu',
      'B) LengvƒÖ u≈ækandƒØ',
      'C) Kava'
    ],
    correct: 2 // C
  }
];

    let quizIndex = 0;
    let quizScore = 0;

    // 3 mini-game: KORT≈≤ POROS
    let cards = [];           // {value, matched, flipped}
    let firstCardIndex = null;
    let secondCardIndex = null;
    let matchedPairs = 0;


   // UI elementai
const dialogContainer = document.getElementById('dialogContainer');
const dialogTextEl = document.getElementById('dialogText');
const dialogOptionsEl = document.getElementById('dialogOptions');
const minigameMessage = document.getElementById('minigameMessage');
let minigameMessageTimer = 0;
// --- Princesƒós kalbƒójimo burbuliukas + voice ---
const npcSpeechEl = document.getElementById('npcSpeech');

function playPrincessVoice(vol = 1.0) {
  if (!audio?.princessTalk) return;
  playAudio(audio.princessTalk, vol);
}

// paprastas "typewriter" (gali i≈°jungt, jei nenori)
let _speechTimer = null;
function showNpcSpeech(text, { typeSpeed = 40, autoHide = false, onDone = null } = {}) {
  if (!npcSpeechEl) return;

  if (_speechTimer) clearInterval(_speechTimer);
  _speechTimer = null;

  npcSpeechEl.style.display = 'block';
  npcSpeechEl.textContent = '';

  let i = 0;
  _speechTimer = setInterval(() => {
    npcSpeechEl.textContent += text[i] ?? '';
    i++;
    if (i >= text.length) {
      clearInterval(_speechTimer);
      _speechTimer = null;

      if (autoHide) {
        setTimeout(() => {
          npcSpeechEl.style.display = 'none';
          if (onDone) onDone();
        }, 900);
      } else {
        if (onDone) onDone();
      }
    }
  }, typeSpeed);
}

function hideNpcSpeech() {
  if (!npcSpeechEl) return;
  if (_speechTimer) clearInterval(_speechTimer);
  _speechTimer = null;
  npcSpeechEl.style.display = 'none';
}

// --- LAI≈†KAI: naudojam SENOVINƒÆ pergamentƒÖ (#letter-overlay) ---
let letterCallback = null;

function showLetter(text, buttonLabel = 'Gerai', callback = null) {
  // buttonLabel paliekam (nieko nelau≈æom), bet pergamente jis nerodomas
  letterCallback = callback || null;
  openLetter({
    title: "Princesƒós lai≈°kas",
    body: text,
    typeSpeed: 18
  });
}

// U≈ædarymo callback (kai u≈ædarai su Enter/Esc/click)
const _origCloseLetter = closeLetter;
closeLetter = function () {
  _origCloseLetter();

  unlockAudioOnce();
  // ‚ùå lastZone = null;  // NEBENULINAM, kad muzika nesirestartint≈≥
  updateZoneMusic();

  const cb = letterCallback;
  letterCallback = null;
  if (cb) cb();
};


// ------------------------------------------------------------

// Istorijos vƒóliavƒólƒós
let letterIntroShown = false;
let letterAfterStartShown = false;
let letterDziugasShown = false;
let letterBridgeShown = false;
let letterCatShown = false;
let letterTowerShown = false;
let letterPrincessTaskShown = false;
let letterFinalShown = false;
let breakdanceDone = false;
let breakdanceSavedRot = null; // {x,y,z}
let ninjaPivot = null;
let breakdanceFix = null;
let breakdanceBaseY = 0;
const BREAKDANCE_RAISE_Y = 0.8; // kiek pakelti (0.6‚Äì1.2)
let showPressMHint = false;
let kissReady = false;
const KISS_TARGET_SECONDS = 30; // ‚úÖ kiek sekund≈æi≈≥ turi trukti kiss

let kissStarted = false;
let kissApproach = false;
let kissAutoTimer = null;
let kissReadyPoll = null;
let ninjaKissAction = null;
let princessKissAction = null;


let kissNinjaTarget = new THREE.Vector3();
let kissPrincessTarget = new THREE.Vector3();
let pendingKissPress = false;
let ninjaKissClip = null;
let princessKissClip = null;
let kissCamTime = 0;
const kissCam = {
  pos: new THREE.Vector3(),
  mid: new THREE.Vector3(),
  initialized: false
};
// üé¨ THE END sequence
let endSequenceStarted = false;

function startEndSequence() {
  if (endSequenceStarted) return;
  endSequenceStarted = true;

  // u≈ærakinam judƒójimƒÖ (muzikos NELIEƒåIAM)
  controlsLocked = true;
  keys.forward = keys.back = keys.left = keys.right = keys.shift = false;

  const overlay = document.getElementById('end-overlay');
  if (!overlay) return;

  overlay.style.display = 'block';
  overlay.style.opacity = '0';

  const FADE_SEC = 20; // ‚úÖ 30 sekund≈æi≈≥ u≈ætemimas
  const t0 = performance.now();

  const step = () => {
    const t = (performance.now() - t0) / (FADE_SEC * 1000);
    const a = Math.min(1, Math.max(0, t));
    overlay.style.opacity = String(a);

    if (a < 1) requestAnimationFrame(step);
  };

  requestAnimationFrame(step);
}

function buildKissActionsIfPossible() {
  // Ninja
  if (mixer && ninja && ninjaKissClip && !ninjaKissAction) {
    ninjaKissAction = mixer.clipAction(ninjaKissClip, ninja); // ‚úÖ root ai≈°kiai = ninja
    ninjaKissAction.setLoop(THREE.LoopOnce);
    ninjaKissAction.clampWhenFinished = true;
  }

  // Princess
  if (princessMixer && princess && princessKissClip && !princessKissAction) {
    princessKissAction = princessMixer.clipAction(princessKissClip, princess); // ‚úÖ root ai≈°kiai = princess
    princessKissAction.setLoop(THREE.LoopOnce);
    princessKissAction.clampWhenFinished = true;
  }

  kissReady = !!(ninjaKissAction && princessKissAction);

  // jei M buvo paspaustas anksƒçiau ‚Äì paleid≈æiam kai tik pasiruo≈°ƒó
  if (kissReady && pendingKissPress && !kissStarted) {
    pendingKissPress = false;
    startKissApproach();
  }
  console.log('KISS READY?', kissReady, {
  ninjaClip: !!ninjaKissClip,
  princessClip: !!princessKissClip,
  ninjaAction: !!ninjaKissAction,
  princessAction: !!princessKissAction
});

}


// --- Vienkartiniai "instrukcij≈≥" lai≈°kai ---
let letterGateEShown = false;
let lastDoorHintIndex = -2; // kad atsekt≈≥, prie kuri≈≥ dur≈≥ priƒójai
const doorHintShown = [false, false, false];



    // Mini-games UI elementai
    
    const aimOverlay = document.getElementById('aimGameOverlay');
    const aimInfo = document.getElementById('aimGameInfo');
    const aimTargetsContainer = document.getElementById('aimGameTargetsContainer');

    const quizOverlay = document.getElementById('quizOverlay');
    const quizQuestionEl = document.getElementById('quizQuestion');
    const quizProgressEl = document.getElementById('quizProgress');
    const quizOptionsEl = document.getElementById('quizOptions');

    const cardsOverlay = document.getElementById('cardsOverlay');
    const cardsInfoEl = document.getElementById('cardsInfo');
    const cardsGridEl = document.getElementById('cardsGrid');

    if (dialogOptionsEl) {
      dialogOptionsEl.addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (!btn) return;
        const choice = btn.dataset.choice || 'A';
        handleDialogChoice(choice);
      });
    }
    // 1 mini-game: AIM ‚Äì paspaudus ant taikinio
if (aimTargetsContainer) {
  aimTargetsContainer.addEventListener('click', (e) => {
    if (!minigameInProgress || activeMinigameDoor !== 0) return;

    const targetEl = e.target.closest('.aim-target');
    if (!targetEl) return;   // nepataikei ƒØ taikinƒØ

    // bet kur ant taikinio ‚Äì +1
    aimScore += 1;
    targetEl.remove();

    if (aimInfo) {
      const left = Math.max(0, Math.ceil(AIM_TIME_LIMIT - minigameTimer));
      aimInfo.textContent = `Ta≈°kai: ${aimScore} | Liko: ${left}s`;
    }
  });
}


    // 2 mini-game: QUIZ ‚Äì paspaudus atsakymo mygtukƒÖ
    if (quizOptionsEl) {
      quizOptionsEl.addEventListener('click', (e) => {
        if (!minigameInProgress || activeMinigameDoor !== 1) return;
        const btn = e.target.closest('button[data-index]');
        if (!btn) return;
        const idx = parseInt(btn.dataset.index, 10);
        handleQuizAnswer(idx);
      });
    }

    // 3 mini-game: CARDS ‚Äì paspaudus kortƒÖ
    if (cardsGridEl) {
      cardsGridEl.addEventListener('click', (e) => {
        if (!minigameInProgress || activeMinigameDoor !== 2) return;
        const btn = e.target.closest('button[data-card-index]');
        if (!btn) return;
        const idx = parseInt(btn.dataset.cardIndex, 10);
        handleCardClick(idx);
      });
    }

    const BREAKDANCE_Y_OFFSET = 0.6;

    // ---------- START ----------
    init();
    animate();

    // ---------- D≈ΩIUGAS QUEST ----------
    function checkDziugasQuest() {
      if (!ninja || !dziugas || dziugasFound) return;
      const dx = ninja.position.x - dziugas.position.x;
      const dz = ninja.position.z - dziugas.position.z;
      const distSq = dx * dx + dz * dz;
      if (distSq < 4) {
        dziugasFound = true;
        console.log('üéâ Radai D≈æiugƒÖ! Dabar jis seka tave.');

        if (!letterDziugasShown) {
          letterDziugasShown = true;
          showLetter(
           'Tu radai D≈æiugƒÖ. ü´∂\n\nDabar ‚Äî link lavos tilto.\nTik atsargiai‚Ä¶'
,
            'Gerai, judu link tilto!'
          );
        }
      }
    }


    function updateFollowerFollow(follower, followSpeed, delta, sideSign) {
      if (!follower || !ninja) return;

      const behindDist = 2.0;
      const sideOffset = 0.8;

      const yaw = ninja.rotation.y;

      const backX = ninja.position.x - Math.sin(yaw) * behindDist;
      const backZ = ninja.position.z - Math.cos(yaw) * behindDist;

      const sideX = Math.cos(yaw) * sideOffset * sideSign;
      const sideZ = -Math.sin(yaw) * sideOffset * sideSign;

      const targetX = backX + sideX;
      const targetZ = backZ + sideZ;

      const dx = targetX - follower.position.x;
      const dz = targetZ - follower.position.z;
      const dist = Math.sqrt(dx * dx + dz * dz);

      const followDistance = 0.25;
      const catchupDistance = 7.0;

      if (dist > catchupDistance) {
        const snapPos = { x: targetX, y: 0, z: targetZ };
        if (isOnSafeGround(snapPos) && !isBlockedByCastleWalls(targetX, targetZ)) {
          follower.position.x = targetX;
          follower.position.z = targetZ;
        }
        return;
      }

      if (dist > followDistance) {
        const dirX = dx / dist;
        const dirZ = dz / dist;

        const maxStep = followSpeed * delta;
        const moveDist = Math.min(maxStep, dist - followDistance);

        const newX = follower.position.x + dirX * moveDist;
        const newZ = follower.position.z + dirZ * moveDist;

        const candidatePos = { x: newX, y: 0, z: newZ };
        if (isOnSafeGround(candidatePos) && !isBlockedByCastleWalls(newX, newZ)) {
          follower.position.x = newX;
          follower.position.z = newZ;
        }
      }
    }

    function updateDziugasFollow(delta) {
      if (!dziugas || !ninja || !dziugasFound) return;
      updateFollowerFollow(dziugas, dziugasFollowSpeed, delta, -1);
      dziugas.rotation.y = ninja.rotation.y - Math.PI / 2;
      dziugas.position.y = 1.2;
    }

    // Katinas
    function updateCatFollow(delta) {
      if (!cat || !catFollowing || !ninja) return;
      updateFollowerFollow(cat, catFollowSpeed, delta, +1);
      cat.rotation.y = ninja.rotation.y + CAT_ROT_OFFSET;
    }

    // ---------- PILIES "WIN" ----------
    function checkCastleWin() {
      if (!ninja || castleCompleted) return;

      const dx = ninja.position.x - goalPos.x;
      const dz = ninja.position.z - goalPos.z;
      const distSq = dx * dx + dz * dz;
      const radiusSq = 10 * 10;

      if (distSq < radiusSq) {
        if (!dziugasFound) {
          console.log('üö´ Pirmiausia surask D≈æiugƒÖ mi≈°ke.');
        } else if (!catFollowing) {
          console.log('üö´ Prie pilies vart≈≥ su ‚ÄûP‚Äú prisikviesk katinƒÖ.');
        } else {
          castleCompleted = true;
          console.log('üéâ MISIJA ƒÆVYKDYTA! ƒÆ pilƒØ atƒójote trise ‚Äì ninja, D≈æiugas ir katinas.');
        }
      }
    }

    // ---------- VARTAI ----------
    function tryOpenGate() {
      if (!castleGate || castleGateOpen || !ninja) return;
      const gateZ = goalPos.z + CASTLE_YARD_HALF_Z;
      const dx = ninja.position.x - goalPos.x;
      const dz = ninja.position.z - gateZ;
      const distSq = dx * dx + dz * dz;
      if (distSq < 6 * 6) {
        castleGateOpen = true;
        console.log('üö™ Vartai atsidaro!');
        
updateZoneMusic();

      }
    }

    function updateCastleGate(delta) {
      if (!castleGate) return;
      const closedY = castleGate.userData.closedY || castleGate.position.y;
      const openY = closedY + 10;
      const targetY = castleGateOpen ? openY : closedY;
      castleGate.position.y = THREE.MathUtils.lerp(
        castleGate.position.y,
        targetY,
        3 * delta
      );
    }

    // ---------- KATINO QUEST ----------
     function tryCharmCat() {
      if (!cat || catFollowing || !ninja) return;

      const dx = ninja.position.x - cat.position.x;
      const dz = ninja.position.z - cat.position.z;
      const distSq = dx*dx + dz*dz;

      // Katinas PER TOLI ‚Üí tik PSST
      if (distSq > 4*4) {
        playAudio(audio.catPsst, 1.0);
        console.log("üê± Katinas per toli ‚Äì priartƒók ir tada spausk P.");
        return;
      }

      // Katinas pakankamai arti ‚Üí PRISIJUNGIA
      catFollowing = true;
      console.log("üê± Katinas prisijungƒó prie tavƒôs.");

     // lai≈°kas apie vartus ir paneles (PERGAMENTAS)
if (!letterCatShown) {
  letterCatShown = true;
  openLetter({
    title: "Princesƒós lai≈°kas",
body:
`Gerai‚Ä¶ dabar j≈´s jau tryse. üòºüñ§

Prie vart≈≥ spausk E.

Viduje tavƒôs lauks panelƒós.
Jos nori su≈æinoti ant kiek stipriai mane ≈æinai, todƒól bus grie≈ætos‚Ä¶
Atsakyk ramiai ir teisingai.

A≈° tikiu tavim.(Visados)
‚Äî Princesƒó`

  });
}

      // Meow garsas su ≈°velniu delay
      setTimeout(() => {
        playAudio(audio.catMeow, 0.7);
      }, 300);
    }


    // ---------- INIT ----------
    function init() {
      const canvas = document.getElementById('game');

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x151d14);
      scene.fog = new THREE.FogExp2(0x151d14, 0.02);

      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        600
      );
      camera.position.set(0, 4, 10);

      renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
      renderer.setPixelRatio(1.0);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;

      const dirLight = new THREE.DirectionalLight(0xcfd8ff, 1.4);
      dirLight.position.set(-10, 18, 5);
      scene.add(dirLight);
      const ambient = new THREE.AmbientLight(0xa0b0a0, 0.7);
      scene.add(ambient);

      const texLoader = new THREE.TextureLoader();

      // pasaulis
      createWorldGround(texLoader);
      createForestIsland(texLoader);
      createLowPolyForest(texLoader);
      createBigLava(texLoader);
      createCastlePlatform(texLoader);
      createCastleBuilding(texLoader);
      createWideBridge();
      createTowerRoom(texLoader);
      createPrincessTowerRoom(texLoader);

      // Ninja
      const loader = new GLTFLoader();
      loader.load(
        './models/ninja@idle.glb',
        (gltf) => {
        ninja = gltf.scene;
ninja.scale.set(1.6, 1.6, 1.6);
ninja.position.set(0, 0, 0);
ninja.rotation.y = Math.PI;
ninja.traverse(o => {
  if (!o.isBone) return;
  const n = o.name.toLowerCase();

  if (n.includes('hip')) hipsBone = o;

  // mixamo/kit≈≥ rig≈≥ pƒódos
  if (n.includes('leftfoot') || n.includes('rightfoot') ||
      n.includes('mixamorigleftfoot') || n.includes('mixamorigrighfoot') ||
      n.includes('lefttoe') || n.includes('righttoe') ||
      n.includes('mixamoriglefttoe') || n.includes('mixamorigrightoe')) {
    footBones.push(o);
  }
});

console.log('HIPS:', hipsBone?.name);
console.log('FOOT BONES:', footBones.map(b => b.name));


// ‚úÖ wrapperis (pivot) ‚Äì NORMALIAI nieko nekeiƒçia
ninjaPivot = new THREE.Object3D();
scene.add(ninjaPivot);
ninjaPivot.add(ninja);

mixer = new THREE.AnimationMixer(ninja);

// ‚úÖ PRIDƒñK ≈†ITƒÑ:
buildKissActionsIfPossible();


          if (gltf.animations && gltf.animations.length > 0) {
            const idleClip = gltf.animations[0];
            actions.idle = mixer.clipAction(idleClip);
            activeAction = actions.idle;
            activeAction.play();
          }
function rotateHipsQuatInClip(clip, eulerFix) {
  const qFix = new THREE.Quaternion().setFromEuler(eulerFix);

  for (const t of clip.tracks) {
    const n = t.name.toLowerCase();
    if (!n.endsWith('.quaternion')) continue;

    // taikom tik hips/root tipo kaulams (Mixamo)
    const looksLikeHips =
      n.includes('hips') || n.includes('mixamorig:hips') || n.includes('mixamorighips');

    if (!looksLikeHips) continue;

    const v = t.values; // [x,y,z,w,x,y,z,w,...]
    const q = new THREE.Quaternion();

    for (let i = 0; i < v.length; i += 4) {
      q.set(v[i], v[i+1], v[i+2], v[i+3]);

      // ‚úÖ pritaikom pasukimƒÖ vienƒÖ kartƒÖ klipui
      q.premultiply(qFix);

      v[i]   = q.x;
      v[i+1] = q.y;
      v[i+2] = q.z;
      v[i+3] = q.w;
    }
  }
  return clip;
}

          loadAnim('walk', './models/ninja@walking.glb');
          loadAnim('run',  './models/ninja@running.glb');
          loadAnim('jump', './models/ninja@jump.glb');
        loadAnim('breakdance', './models/ninja_Breakdance.fbx', true);
// ‚úÖ PIRMAS LAI≈†KAS ‚Äì kai tik u≈æsikrauna herojus
setTimeout(() => {
  if (!letterIntroShown) {
    letterIntroShown = true;
  
    openLetter({
      title: "Princesƒós lai≈°kas",
      body:
`Labas, mylimasis. üåô

A≈° ƒçia‚Ä¶ pilyje.
Viena, li≈´dna ir ƒØbauginta savo sergƒótoj≈≥.

Man reikia tavƒôs.
Pirmiausia surask D≈æiugƒÖ mi≈°ke ‚Äî
jis tau palaikys kompanijƒÖ visam kelyje.

A≈° laukiu. ‚ù§Ô∏è
‚Äî Princesƒó`

    });
  }
}, 400);

        },

        undefined,
        (err) => console.error('Klaida ƒØkeliant ninja@idle.glb:', err)
      );

      // D≈æiugas
      const donkeyLoader = new GLTFLoader();
      donkeyLoader.load(
        './models/dziugas_donkey.glb',
        (gltf) => {
          dziugas = gltf.scene;
          dziugas.scale.set(0.8, 0.8, 0.8);

          let spotFound = false;
          let px = 0;
          let pz = 0;
          let tries = 0;

          while (!spotFound && tries < 100) {
            tries++;
            const angle = Math.random() * Math.PI * 2;
            const rMin = 15;
            const rMax = FOREST_RADIUS - 5;
            const r = rMin + Math.random() * (rMax - rMin);

            px = Math.cos(angle) * r;
            pz = Math.sin(angle) * r;

            const distFromStartSq = px * px + pz * pz;
            if (distFromStartSq < 18 * 18) continue;

            if (isPositionBlocked(px, pz)) continue;
            spotFound = true;
          }

          if (!spotFound) {
            px = 20;
            pz = 15;
          }

          dziugas.position.set(px, 1.2, pz);
          dziugas.rotation.set(0, Math.PI / 2, 0);

          dziugas.traverse((obj) => {
            if (obj.isMesh) {
              obj.castShadow = true;
              obj.receiveShadow = true;
            }
          });

          scene.add(dziugas);
        },
        undefined,
        (err) => console.error('Klaida ƒØkeliant dziugas_donkey.glb:', err)
      );

      // Katinas prie pilies
      const catLoader = new GLTFLoader();
      catLoader.load(
        './models/siberian.glb',
        (gltf) => {
          cat = gltf.scene;
          cat.scale.set(0.15, 0.15, 0.15);
          const gateZ = goalPos.z + CASTLE_YARD_HALF_Z + 2;
          cat.position.set(goalPos.x + 6, 0.4, gateZ + 1);
          cat.rotation.y = CAT_ROT_OFFSET;
          cat.traverse((obj) => {
            if (obj.isMesh) {
              obj.castShadow = true;
              obj.receiveShadow = true;
            }
          });
          scene.add(cat);
        },
        undefined,
        (err) => console.error('Klaida ƒØkeliant siberian.glb:', err)
      );

      // NPC merginos + princesƒó
      loadCastleNPCs();
      loadPrincessNPC();

      // Input
      window.addEventListener('keydown', (e) => onKeyChange(e, true));
      window.addEventListener('keyup',   (e) => onKeyChange(e, false));

      canvas.addEventListener('mousedown', (e) => {
        isMouseDown = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        canvas.style.cursor = 'grabbing';
      });
      window.addEventListener('mouseup', () => {
        isMouseDown = false;
        canvas.style.cursor = 'default';
      });
      window.addEventListener('mouseleave', () => {
        isMouseDown = false;
        canvas.style.cursor = 'default';
      });
      window.addEventListener('mousemove', (e) => {
        if (!isMouseDown) return;
        const dx = e.clientX - lastMouseX;
        const dy = e.clientY - lastMouseY;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        camYawOffset -= dx * 0.005;
        camPitch    -= dy * 0.003;
        camPitch = Math.max(-0.4, Math.min(0.9, camPitch));
      });

      window.addEventListener('resize', onResize);
    }


    // ---------- NPC MERGINOS ----------
    function loadCastleNPCs() {
      npcLoader = new FBXLoader();

      const configs = [
        {
          name: 'Female',
          idle: './models/Female Standing Pose.fbx',
          talk: './models/Female Talking.fbx',
          walk: './models/Female Walking.fbx',
          offset: new THREE.Vector3(-10, 0, -10),
          scale: 0.15,
          yOffset: 0.16
        },
        {
          name: 'Annie',
          idle: './models/Annie Standing Idle.fbx',
          talk: './models/Annie Talking.fbx',
          walk: './models/Annie Walking (1).fbx',
          offset: new THREE.Vector3(10, 0, -10),
          scale: 0.014,
          yOffset: 0.16
        },
        {
          name: 'Lara',
          idle: './models/Lara Standing Pose.fbx',
          talk: './models/Lara Talking.fbx',
          walk: './models/Lara Walking (1).fbx',
          offset: new THREE.Vector3(0, 0, 10),
          scale: 0.015,
          yOffset: 0.16
        }
      ];

      configs.forEach(cfg => loadNPCWithSeparateAnimations(cfg));
    }

    function loadNPCWithSeparateAnimations(cfg) {
      const info = {
        name: cfg.name,
        mesh: null,
        mixer: null,
        idleAction: null,
        talkAction: null,
        walkAction: null,
        startPos: null,
        state: 'idle'
      };
      npcInfos.push(info);

      npcLoader.load(cfg.idle, (fbx) => {
        fbx.scale.set(cfg.scale, cfg.scale, cfg.scale);
        fbx.position.set(
          goalPos.x + cfg.offset.x,
          cfg.yOffset,
          goalPos.z + cfg.offset.z
        );

        fbx.traverse((obj) => {
          if (obj.isMesh) {
            obj.castShadow = true;
            obj.receiveShadow = true;
          }
        });

        scene.add(fbx);
        info.mesh = fbx;
        info.startPos = fbx.position.clone();
        info.mixer = new THREE.AnimationMixer(fbx);

        // IDLE
        if (fbx.animations.length > 0) {
          info.idleAction = info.mixer.clipAction(fbx.animations[0]);
          info.idleAction.play();
        }

        // TALK
        if (cfg.talk) {
          npcLoader.load(cfg.talk, (talkFBX) => {
            if (talkFBX.animations.length > 0) {
              info.talkAction = info.mixer.clipAction(talkFBX.animations[0]);
            }
          });
        }

        // WALK
        if (cfg.walk) {
          npcLoader.load(cfg.walk, (walkFBX) => {
            if (walkFBX.animations.length > 0) {
              info.walkAction = info.mixer.clipAction(walkFBX.animations[0]);
            }
          });
        }
      });
    }

    // ---------- PRINCESƒñ ----------
    function createPrincessTowerRoom(texLoader) {
      const stoneTex = texLoader.load('./textures/stone floor.jpg');
      stoneTex.wrapS = stoneTex.wrapT = THREE.RepeatWrapping;
      stoneTex.repeat.set(3, 3);
      stoneTex.colorSpace = THREE.SRGBColorSpace;

      const floorGeo = new THREE.CircleGeometry(PRINCESS_TOWER_RADIUS, 48);
      const floorMat = new THREE.MeshPhongMaterial({ map: stoneTex });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(PRINCESS_TOWER_CENTER.x, 0, PRINCESS_TOWER_CENTER.y);
      scene.add(floor);

      const wallMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
      const wallHeight = 5;
      const wallThickness = 0.7;
      const cX = PRINCESS_TOWER_CENTER.x;
      const cZ = PRINCESS_TOWER_CENTER.y;

      const wallGeoFB = new THREE.BoxGeometry(PRINCESS_TOWER_RADIUS * 2, wallHeight, wallThickness);
      const wallGeoSide = new THREE.BoxGeometry(wallThickness, wallHeight, PRINCESS_TOWER_RADIUS * 2);

      const front = new THREE.Mesh(wallGeoFB, wallMat);
      front.position.set(cX, wallHeight / 2, cZ + PRINCESS_TOWER_RADIUS);
      scene.add(front);

      const back = new THREE.Mesh(wallGeoFB, wallMat);
      back.position.set(cX, wallHeight / 2, cZ - PRINCESS_TOWER_RADIUS);
      scene.add(back);

      const left = new THREE.Mesh(wallGeoSide, wallMat);
      left.position.set(cX - PRINCESS_TOWER_RADIUS, wallHeight / 2, cZ);
      scene.add(left);

      const right = new THREE.Mesh(wallGeoSide, wallMat);
      right.position.set(cX + PRINCESS_TOWER_RADIUS, wallHeight / 2, cZ);
      scene.add(right);
    }
function stripRootMotionFromFBXClip(clip) {
  // i≈°metam position track‚Äôus tik "root/armature/hips", kad animacija nestumt≈≥ ƒØ priekƒØ
  const ROOT_KEYS = ['root', 'armature', 'mixamorigarmature', 'mixamorig:armature'];
  const HIPS_KEYS = ['hips', 'mixamorighips', 'mixamorig:hips'];

  clip.tracks = clip.tracks.filter(t => {
    const n = t.name.toLowerCase();
    if (!n.endsWith('.position')) return true;

    // jei tai root/hips pozicijos trackas ‚Äì i≈°metam
    if (ROOT_KEYS.some(k => n.includes(k))) return false;
    if (HIPS_KEYS.some(k => n.includes(k))) return false;

    return true;
  });

  return clip;
}
function loadKissAnims() {
  const loader = new FBXLoader();

  // 1) Ninja kiss CLIP
  loader.load('./models/ninja_Kiss.fbx', (fbx) => {
    if (fbx.animations && fbx.animations.length > 0) {
      let clip = fbx.animations[0];
      clip = stripRootMotionKeepHipsY(clip); // kad nestumt≈≥ per kambarƒØ
clip = rotateHipsQuatInClip(clip, new THREE.Euler(-Math.PI / 2, 0, 0));

      ninjaKissClip = clip; // ‚úÖ SAUGOM CLIP, ne action
      console.log('üíã Ninja kiss clip loaded');

      buildKissActionsIfPossible(); // ‚úÖ bandome sukurti action, jei jau yra mixer
    }
  });

  // 2) Princess kiss CLIP
  loader.load('./models/princes_Kiss.fbx', (fbx) => {
    if (fbx.animations && fbx.animations.length > 0) {
      let clip = fbx.animations[0];
      clip = stripRootMotionFromFBXClip(clip);

      princessKissClip = clip; // ‚úÖ SAUGOM CLIP
      console.log('üíã Princess kiss clip loaded');

      buildKissActionsIfPossible();
    }
  });
}

    // Princesƒó ‚Äì turi idle / walk / talking animacijas, bet NƒñRA dialog≈≥ sekoje
    function loadPrincessNPC() {
      const loader = new FBXLoader();





      // 1) pagrindinis modelis su idle animacija (standing pose)
      loader.load(
        './models/princesStandingPose.fbx',
        (fbx) => {
          princess = fbx;

          const scale = 0.015;
          princess.scale.set(scale, scale, scale);

          // pastatom princesƒô savo bok≈°to viduje
          princess.position.set(
            PRINCESS_TOWER_CENTER.x,
            0,
            PRINCESS_TOWER_CENTER.y - 3
          );
          princess.rotation.y += Math.PI; // kad ≈æi≈´rƒót≈≥ ƒØ ≈æaidƒójƒÖ

          princess.traverse((obj) => {
            if (obj.isMesh) {
              obj.castShadow = true;
              obj.receiveShadow = true;
            }
          });

          scene.add(princess);
// ‚úÖ paslepiam princesƒô iki tol, kol baigti mini-games
princess.visible = false;
princessApproachAllowed = false;
princessFrozen = false;

          // animacijos mixeris
          princessMixer = new THREE.AnimationMixer(princess);
loadKissAnims(); // ‚úÖ ƒçia
buildKissActionsIfPossible();

          // IDLE animacija i≈° princesStandingPose.fbx
          if (fbx.animations && fbx.animations.length > 0) {
            princessActions.idle = princessMixer.clipAction(fbx.animations[0]);
            princessActions.idle.play();
          }

          // 2) TALK animacija
          loader.load(
            './models/princes Talking.fbx',
            (talkFBX) => {
              if (!princessMixer) return;
              if (talkFBX.animations && talkFBX.animations.length > 0) {
                let clip = talkFBX.animations[0];
clip = stripRootMotionFromFBXClip(clip);
princessActions.talk = princessMixer.clipAction(clip);

                // kol kas nenaudojam, bet turƒósim ateiƒçiai dialogams
              }
            }
          );

          // 3) WALK animacija
          loader.load(
            './models/princes walk.fbx',
            (walkFBX) => {
              if (!princessMixer) return;
              if (walkFBX.animations && walkFBX.animations.length > 0) {
                let clip = walkFBX.animations[0];
clip = stripRootMotionFromFBXClip(clip);
princessActions.walk = princessMixer.clipAction(clip);

                // irgi pasiliekam ateiƒçiai
              }
            }
          );
        },
        undefined,
        (err) => console.error('Klaida ƒØkeliant princesƒô:', err)
      );

      }
    // ---------- GEOMETRIJA ----------
    function createWorldGround(texLoader) {
      const grassTex = texLoader.load('./textures/grass ground.jpg');
      grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
      grassTex.repeat.set(20, 20);
      grassTex.colorSpace = THREE.SRGBColorSpace;

      const groundGeo = new THREE.PlaneGeometry(260, 260);
      const groundMat = new THREE.MeshPhongMaterial({ map: grassTex });

      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.set(0, -0.12, -65);
      scene.add(ground);
    }

    function createForestIsland(texLoader) {
      const grassTex = texLoader.load('./grass.png');
      grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
      grassTex.repeat.set(6, 6);
      grassTex.colorSpace = THREE.SRGBColorSpace;

      const islandGeo = new THREE.CircleGeometry(FOREST_RADIUS, 48);
      const islandMat = new THREE.MeshPhongMaterial({ map: grassTex });

      const island = new THREE.Mesh(islandGeo, islandMat);
      island.rotation.x = -Math.PI / 2;
      island.position.set(0, 0, 0);

      scene.add(island);
    }

    function createCastlePlatform(texLoader) {
      const stoneTex = texLoader.load('./textures/stone floor.jpg');
      stoneTex.wrapS = stoneTex.wrapT = THREE.RepeatWrapping;
      stoneTex.repeat.set(6, 6);
      stoneTex.colorSpace = THREE.SRGBColorSpace;

      const geo = new THREE.CircleGeometry(CASTLE_RADIUS, 64);
      const mat = new THREE.MeshPhongMaterial({ map: stoneTex });

      const platform = new THREE.Mesh(geo, mat);
      platform.rotation.x = -Math.PI / 2;
      platform.position.set(goalPos.x, 0.14, goalPos.z);

      scene.add(platform);
    }

    function createCastleBuilding(texLoader) {
      const wallTex = texLoader.load('./textures/cobblestone.jpg');
      wallTex.wrapS = wallTex.wrapT = THREE.RepeatWrapping;
      wallTex.repeat.set(3, 2);
      wallTex.colorSpace = THREE.SRGBColorSpace;

      const wallMat = new THREE.MeshPhongMaterial({ map: wallTex });

      const castleGroup = new THREE.Group();

      const centerX = goalPos.x;
      const centerZ = goalPos.z;

      const yardHalfX = CASTLE_YARD_HALF_X;
      const yardHalfZ = CASTLE_YARD_HALF_Z;

      const wallThickness = CASTLE_WALL_THICKNESS;
      const wallHeight = 10;

      const frontZ = centerZ + yardHalfZ;
      const backZ  = centerZ - yardHalfZ;

      const gateHalf = CASTLE_GATE_WIDTH * 0.5;
      const frontSegmentWidth = yardHalfX - gateHalf;

      const frontGeo = new THREE.BoxGeometry(frontSegmentWidth, wallHeight, wallThickness);

      const frontLeft = new THREE.Mesh(frontGeo, wallMat);
      frontLeft.position.set(
        centerX - (gateHalf + frontSegmentWidth * 0.5),
        wallHeight / 2 + 0.14,
        frontZ - wallThickness / 2
      );
      castleGroup.add(frontLeft);

      const frontRight = new THREE.Mesh(frontGeo, wallMat);
      frontRight.position.set(
        centerX + (gateHalf + frontSegmentWidth * 0.5),
        wallHeight / 2 + 0.14,
        frontZ - wallThickness / 2
      );
      castleGroup.add(frontRight);

      const gateDoorGeo = new THREE.BoxGeometry(
        CASTLE_GATE_WIDTH,
        wallHeight * 0.8,
        wallThickness * 0.5
      );
      const gateDoorMat = new THREE.MeshPhongMaterial({ color: 0x5c3a1a });

      castleGate = new THREE.Mesh(gateDoorGeo, gateDoorMat);
      castleGate.position.set(
        centerX,
        wallHeight * 0.4 + 0.14,
        frontZ - wallThickness * 0.25
      );
      castleGate.rotation.y = Math.PI;
      castleGate.userData.closedY = castleGate.position.y;
      castleGroup.add(castleGate);

      const backGeo = new THREE.BoxGeometry(
        yardHalfX * 2 + wallThickness,
        wallHeight,
        wallThickness
      );
      const backWall = new THREE.Mesh(backGeo, wallMat);
      backWall.position.set(centerX, wallHeight / 2 + 0.14, backZ);
      castleGroup.add(backWall);

      const sideGeo = new THREE.BoxGeometry(
        wallThickness,
        wallHeight,
        yardHalfZ * 2 + wallThickness
      );
      const leftWall = new THREE.Mesh(sideGeo, wallMat);
      leftWall.position.set(centerX - yardHalfX, wallHeight / 2 + 0.14, centerZ);
      castleGroup.add(leftWall);

      const rightWall = leftWall.clone();
      rightWall.position.x = centerX + yardHalfX;
      castleGroup.add(rightWall);

      const towerGeo = new THREE.BoxGeometry(8, 16, 8);
      const tower = new THREE.Mesh(towerGeo, wallMat);
      tower.position.set(centerX, 16 / 2 + 0.14, centerZ);
      castleGroup.add(tower);

      scene.add(castleGroup);
    }

    function createBigLava(texLoader) {
      const lavaBase = texLoader.load('./textures/lava_base.jpg');
      const lavaEmissive = texLoader.load('./textures/lava_emissive.jpg');
      const lavaNormal = texLoader.load('./textures/lava_normal.jpg');

      [lavaBase, lavaEmissive, lavaNormal].forEach((tex) => {
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(8, 8);
        tex.colorSpace = THREE.SRGBColorSpace;
      });

      const lavaMat = new THREE.MeshStandardMaterial({
        map: lavaBase,
        emissive: new THREE.Color(0xff4400),
        emissiveMap: lavaEmissive,
        emissiveIntensity: 2.0,
        normalMap: lavaNormal,
      });

      const lavaGeo = new THREE.PlaneGeometry(260, 260);
      const lava = new THREE.Mesh(lavaGeo, lavaMat);
      lava.rotation.x = -Math.PI / 2;
      lava.position.set(0, -0.1, -65);

      scene.add(lava);
    }

    function createWideBridge() {
      const bridgeGroup = new THREE.Group();

      const deckMat = new THREE.MeshPhongMaterial({ color: 0x4b3a28 });
      const postMat = new THREE.MeshPhongMaterial({ color: 0x3a2a1c });
      const railMat = new THREE.MeshPhongMaterial({ color: 0x2c1d12 });

      const postGeo = new THREE.CylinderGeometry(0.08, 0.1, 1.1, 6);
      const railGeo = new THREE.BoxGeometry(0.08, 0.12, BRIDGE_SEG_DEPTH - 1);

      function makeBridgeSegment(zCenter) {
        const seg = new THREE.Mesh(
          new THREE.BoxGeometry(BRIDGE_WIDTH, BRIDGE_PLANK_HEIGHT, BRIDGE_SEG_DEPTH),
          deckMat
        );
        seg.position.set(BRIDGE_X, -BRIDGE_PLANK_HEIGHT / 3, zCenter);
        seg.castShadow = seg.receiveShadow = true;
        seg.userData.baseY = seg.position.y;
        bridgeSegments.push(seg);
        bridgeGroup.add(seg);

        const halfDepth = BRIDGE_SEG_DEPTH / 2;
        const xLeft  = BRIDGE_X - BRIDGE_WIDTH / 2 + 0.2;
        const xRight = BRIDGE_X + BRIDGE_WIDTH / 2 - 0.2;
        const zFront = zCenter - halfDepth + 0.7;
        const zBack  = zCenter + halfDepth - 0.7;
        const yPost  = 0.9;

        function addPost(px, pz) {
          const post = new THREE.Mesh(postGeo, postMat);
          post.position.set(px, yPost, pz);
          post.castShadow = post.receiveShadow = true;
          bridgeGroup.add(post);
        }

        addPost(xLeft,  zFront);
        addPost(xRight, zFront);
        addPost(xLeft,  zBack);
        addPost(xRight, zBack);

        const railLeft = new THREE.Mesh(railGeo, railMat);
        railLeft.position.set(xLeft, yPost + 0.45, zCenter);
        railLeft.castShadow = railLeft.receiveShadow = true;
        bridgeGroup.add(railLeft);

        const railRight = new THREE.Mesh(railGeo, railMat);
        railRight.position.set(xRight, yPost + 0.45, zCenter);
        railRight.castShadow = railRight.receiveShadow = true;
        bridgeGroup.add(railRight);
      }

      makeBridgeSegment(BRIDGE_SEG1_Z);
      makeBridgeSegment(BRIDGE_SEG2_Z);
      makeBridgeSegment(BRIDGE_SEG3_Z);

      scene.add(bridgeGroup);
    }

    function updateBridgeWobble() {
      for (const seg of bridgeSegments) {
        seg.position.y = seg.userData.baseY;
        seg.rotation.z = 0;
      }
    }

    function createLowPolyForest(texLoader) {
      const trunkGeo = new THREE.CylinderGeometry(0.15, 0.25, 1.8, 6);
      const trunkMat = new THREE.MeshPhongMaterial({ color: 0x3b2b1a });

      const treeTex = texLoader.load('./textures/tree_snow.png');
      treeTex.colorSpace = THREE.SRGBColorSpace;

      const treeMat = new THREE.MeshBasicMaterial({
        map: treeTex,
        transparent: true,
        alphaTest: 0.4,
        side: THREE.DoubleSide
      });

      const treeGeo = new THREE.PlaneGeometry(3, 5);
      const treeCount = 100;

      const innerRadius = 6;
      const outerRadius = FOREST_RADIUS - 3;

      const treeGroup = new THREE.Group();

      let placed = 0;
      let tries = 0;

      while (placed < treeCount && tries < treeCount * 4) {
        tries++;
        const angle = Math.random() * Math.PI * 2;
        const radius = innerRadius + (outerRadius - innerRadius) * Math.random();

        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const y = 0;

        const inBridgeCorridor =
          Math.abs(x - BRIDGE_X) < BRIDGE_WIDTH * 2 &&
          z < 8 && z > (BRIDGE_SEG1_Z - BRIDGE_SEG_DEPTH);
        if (inBridgeCorridor) continue;

        let scale;
        const r = Math.random();
        if (r < 0.25) {
          scale = 1.5 + Math.random() * 2;
        } else if (r < 0.7) {
          scale = 0.9 + Math.random() * 1;
        } else {
          scale = 0.5 + Math.random() * 0.5;
        }

        const tree = new THREE.Group();

        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.scale.setScalar(scale);
        trunk.position.set(0, 0.9 * scale, 0);
        tree.add(trunk);

        const plane1 = new THREE.Mesh(treeGeo, treeMat);
        plane1.scale.setScalar(scale);
        plane1.position.set(0, 2.2 * scale, 0);
        tree.add(plane1);

        const plane2 = new THREE.Mesh(treeGeo, treeMat);
        plane2.scale.setScalar(scale);
        plane2.position.set(0, 2.2 * scale, 0);
        plane2.rotation.y = Math.PI / 2;
        tree.add(plane2);

        tree.position.set(x, y, z);

        treeGroup.add(tree);
        treesData.push({ x, z });
        placed++;
      }

      scene.add(treeGroup);
      
    }

    // BOK≈†TO KAMBARYS ‚Äì 3 durys
    function createTowerRoom(texLoader) {
      const stoneTex = texLoader.load('./textures/stone floor.jpg');
      stoneTex.wrapS = stoneTex.wrapT = THREE.RepeatWrapping;
      stoneTex.repeat.set(4, 4);
      stoneTex.colorSpace = THREE.SRGBColorSpace;

      const floorGeo = new THREE.CircleGeometry(TOWER_ROOM_RADIUS, 48);
      const floorMat = new THREE.MeshPhongMaterial({ map: stoneTex });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.set(TOWER_ROOM_CENTER.x, 0, TOWER_ROOM_CENTER.y);
      scene.add(floor);

      const wallMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
      const wallHeight = 6;
      const wallThickness = 0.8;
      const wCenterX = TOWER_ROOM_CENTER.x;
      const wCenterZ = TOWER_ROOM_CENTER.y;

      const wallGeoFrontBack = new THREE.BoxGeometry(TOWER_ROOM_RADIUS * 2, wallHeight, wallThickness);
      const wallGeoSide = new THREE.BoxGeometry(wallThickness, wallHeight, TOWER_ROOM_RADIUS * 2);

      const wallFront = new THREE.Mesh(wallGeoFrontBack, wallMat);
      wallFront.position.set(wCenterX, wallHeight / 2, wCenterZ + TOWER_ROOM_RADIUS);
      scene.add(wallFront);

      const wallBack = new THREE.Mesh(wallGeoFrontBack, wallMat);
      wallBack.position.set(wCenterX, wallHeight / 2, wCenterZ - TOWER_ROOM_RADIUS);
      scene.add(wallBack);

      const wallLeft = new THREE.Mesh(wallGeoSide, wallMat);
      wallLeft.position.set(wCenterX - TOWER_ROOM_RADIUS, wallHeight / 2, wCenterZ);
      scene.add(wallLeft);

      const wallRight = new THREE.Mesh(wallGeoSide, wallMat);
      wallRight.position.set(wCenterX + TOWER_ROOM_RADIUS, wallHeight / 2, wCenterZ);
      scene.add(wallRight);

      // durys
      const doorGeo = new THREE.BoxGeometry(2, 4, 0.4);
      const doorMat = new THREE.MeshPhongMaterial({ color: 0x555555 });

      const positions = [
        new THREE.Vector3(wCenterX - 6, 2, wCenterZ - 3),
        new THREE.Vector3(wCenterX,     2, wCenterZ - 6),
        new THREE.Vector3(wCenterX + 6, 2, wCenterZ - 3)
      ];

      positions.forEach((p) => {
        const door = new THREE.Mesh(doorGeo, doorMat);
        door.position.copy(p);
        scene.add(door);
        doorObjects.push(door);
      });
    }

    // ---------- ANIMACIJOS (ninja) ----------
// ---------- ANIMACIJOS (ninja) ----------
function stripRootMotionKeepHipsY(clip) {
  const ROOT = ['root', 'armature', 'mixamorigarmature', 'mixamorig:armature'];
  const HIPS = ['hips', 'mixamorighips', 'mixamorig:hips'];

  clip.tracks = clip.tracks.filter(t => {
    const n = t.name.toLowerCase();
    const isPos  = n.endsWith('.position');
    const isQuat = n.endsWith('.quaternion');

    if (isPos  && ROOT.some(r => n.includes(r))) return false;
    if (isQuat && ROOT.some(r => n.includes(r))) return false;

    return true;
  });

   for (const t of clip.tracks) {
    const n = t.name.toLowerCase();
    if (!n.endsWith('.position')) continue;
    if (!HIPS.some(h => n.includes(h))) continue;

    const v = t.values;
    const x0 = v[0];
    const y0 = v[1];   // ‚úÖ PRIDƒñTA
    const z0 = v[2];

    for (let i = 0; i < v.length; i += 3) {
      v[i + 0] = x0;
      v[i + 1] = y0;   // ‚úÖ PRIDƒñTA (u≈ærakina vertikalƒô)
      v[i + 2] = z0;
    }
  }


  return clip;
}


function rotateHipsQuatInClip(clip, eulerFix) {
  const qFix = new THREE.Quaternion().setFromEuler(eulerFix);

  for (const t of clip.tracks) {
    const n = t.name.toLowerCase();
    if (!n.endsWith('.quaternion')) continue;

    const looksLikeHips =
      n.includes('hips') || n.includes('mixamorig:hips') || n.includes('mixamorighips');

    if (!looksLikeHips) continue;

    const v = t.values;
    const q = new THREE.Quaternion();

    for (let i = 0; i < v.length; i += 4) {
      q.set(v[i], v[i+1], v[i+2], v[i+3]);
      q.premultiply(qFix);
      v[i]   = q.x;
      v[i+1] = q.y;
      v[i+2] = q.z;
      v[i+3] = q.w;
    }
  }
  return clip;
}


// ‚úÖ ƒåIA yra TIKRAS loadAnim
function loadAnim(name, url, useFBX = false) {
  if (useFBX) {
    const loader = new FBXLoader();
    loader.load(
      url,
      (fbx) => {
        if (!mixer) return;
        if (fbx.animations && fbx.animations.length > 0) {
          let clip = fbx.animations[0];
          if (name === 'breakdance') {
  clip = stripRootMotionKeepHipsY(clip);

  // ‚úÖ vienas fixas, jokio pivot, jokio per-frame
  clip = rotateHipsQuatInClip(clip, new THREE.Euler(-Math.PI / 2, 0, 0));
}


          actions[name] = mixer.clipAction(clip);
        }
      },
      undefined,
      (err) => console.error('Klaida ƒØkeliant FBX animacijƒÖ', url, err)
    );
  } else {
    const loader = new GLTFLoader();
    loader.load(
      url,
      (gltf) => {
        if (!mixer) return;
        if (gltf.animations && gltf.animations.length > 0) {
          const clip = gltf.animations[0];
          actions[name] = mixer.clipAction(clip);
        }
      },
      undefined,
      (err) => console.error('Klaida ƒØkeliant GLB animacijƒÖ', url, err)
    );
  }
}


    function fadeToAction(name, duration = 0.15, loopOnce = false) {
      const action = actions[name];
      if (!action || activeAction === action) return;
      const prev = activeAction;
      activeAction = action;

      if (loopOnce) {
        action.setLoop(THREE.LoopOnce);
        action.clampWhenFinished = true;
      } else {
        action.setLoop(THREE.LoopRepeat);
        action.clampWhenFinished = false;
      }

      action.reset().fadeIn(duration).play();
      if (prev) prev.fadeOut(duration);
      
    }
 
 function startBreakdance() {
  clearAutoKissTimers();

  if (!actions.breakdance || !ninja) return;
  if (breakdanceDone) return;
  if (musicOverride === 'breakdance') return;

  const inPrincessZone = (getZone() === 'princess');
  if (!inPrincessZone) {
    showMinigameMessage('üí° Breakdance tik prie princesƒós bok≈°te.');
    return;
  }

  keys.forward = keys.back = keys.left = keys.right = false;
  controlsLocked = true;
  velY = 0;
  onGround = true;

  if (princessScene === 'afterMinigames') {
    hideNpcSpeech();
    princessScene = null;
    princessFrozen = false;
  }

  musicOverride = 'breakdance';

  if (currentMusic && currentMusic !== music.breakdance) {
    try { currentMusic.pause(); } catch(e) {}
  }

  try {
    music.breakdance.pause();
    music.breakdance.currentTime = 0;
  } catch(e) {}

  music.breakdance.volume = 0.60;
  music.breakdance.play().catch(()=>{});
  currentMusic = music.breakdance;

  const bd = actions.breakdance;
  bd.setLoop(THREE.LoopRepeat);
  bd.clampWhenFinished = false;

  fadeToAction('breakdance', 0.15, false);

  breakdanceBaseY = ninja.position.y;
  ninja.position.y = breakdanceBaseY + BREAKDANCE_RAISE_Y;

  const finish = () => {
    musicOverride = null;

    if (actions.breakdance) {
      actions.breakdance.fadeOut(0.12);
      setTimeout(() => {
        try { actions.breakdance.stop(); } catch(e) {}
      }, 140);
    }

    fadeToAction('idle', 0.15);
    ninja.position.y = breakdanceBaseY;

    currentMusic = null;
    updateZoneMusic();

    controlsLocked = true;
    breakdanceDone = true;

    princessScene = 'afterBreakdance';
    princessSceneStarted = false;
    princessFrozen = false;
    princessApproachAllowed = true;

    princessSceneText =
      'Tu tai padarei.\n\n' +
      'Aƒçi≈´, kad atƒójai iki pat galo.\n' +
      'A≈° tikrai did≈æiuojuosi tavimi. ‚ù§Ô∏è\n\n' +
      'Myliu tave.\nLabai. ‚ù§Ô∏è';
  };

  music.breakdance.onended = finish;
}



    // ---------- INPUT ----------
    function onKeyChange(event, isDown) {
      const key = event.key;
// jei atidarytas lai≈°kas ‚Äì u≈æblokuojam visus valdymus (w/a/s/d/e/p/f/b ir t.t.)
if (letterOpen && !npcWaitingForAnswer) return;


      if (key === 'w' || key === 'W' || key === 'ArrowUp')    keys.forward = isDown;
      if (key === 's' || key === 'S' || key === 'ArrowDown')  keys.back    = isDown;
      if (key === 'a' || key === 'A' || key === 'ArrowLeft')  keys.left    = isDown;
      if (key === 'd' || key === 'D' || key === 'ArrowRight') keys.right   = isDown;
      if (key === 'Shift') keys.shift = isDown;

      // ≈°uolis
      if (key === ' ' && isDown) {
        if (onGround && !isJumping && actions.jump) {
          isJumping = true;
          velY = JUMP_FORCE;
          fadeToAction('jump', 0.1, true);
        }
      }

      // vartai
      if ((key === 'e' || key === 'E') && isDown) {
        tryOpenGate();
      }

      // katinas
      if ((key === 'p' || key === 'P') && isDown) {
        tryCharmCat();
      }

      // mini-games F
      if ((key === 'f' || key === 'F') && isDown) {
        tryStartMinigame();
      }
// BREAKDANCE ‚Äî paspaudi B
if ((key === 'b' || key === 'B') && isDown) {
  startBreakdance();
}
// üß™ DEV SKIP: T -> ƒØ princesƒós bok≈°tƒÖ po mini-games
if ((key === 't' || key === 'T') && isDown) {
  // pa≈æymim mini-games kaip baigtus (kad logika nelaukt≈≥ dur≈≥)
  miniGamesCompleted[0] = true;
  miniGamesCompleted[1] = true;
  miniGamesCompleted[2] = true;

  // kad rodyt≈≥si princesƒó ir leist≈≥ scenƒÖ
  princessApproachAllowed = true;
  princessFrozen = false;
  princessScene = 'afterMinigames';
  princessSceneStarted = false;
  princessSceneText =
    'Pagaliau‚Ä¶ tu ƒçia. ‚ù§Ô∏è\n\n' +
    'Bet dar vienas dalykas.\n' +
    'Jei nori mano ≈°irdies ‚Äî parodyk man savo geriausiƒÖ breakdance.\n\n' +
    'Spausk B. üòÑ';

  teleportToPrincessTower();
}

// üíã KISS ‚Äî paspaudi M
if ((key === 'm' || key === 'M') && isDown) {
  if (kissStarted || kissApproach) return;

  if (!showPressMHint) {
    showMinigameMessage('Dar negalima üôÇ');
    return;
  }

  // jei animacijos dar kraunasi ‚Äî palaukiam (paspaudimas i≈°saugomas)
  if (!kissReady) {
    pendingKissPress = true;
    showMinigameMessage('‚è≥ Kraunu kiss animacijƒÖ...');
    minigameMessageTimer = 2.0;
    return;
  }

  startKissApproach();
}




    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ---------- MAIN LOOP ----------
    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      if (mixer) mixer.update(delta);

      for (const info of npcInfos) {
        if (info.mixer) info.mixer.update(delta);
      }

      if (princessMixer) princessMixer.update(delta);


      if (ninja) {
        updateMovement(delta);
        updateAnimState();
        updateCamera();
        updateBridgeWobble();
        checkLavaDeath();
        checkDziugasQuest();
        updateDziugasFollow(delta);
        updateCatFollow(delta);
        updateNPCLogic(delta);
        checkCastleWin();
        updateCastleGate(delta);
        checkDoorMinigames();
        updateMinigameTimer(delta);
        drawMinimap();
                checkAfterBridgeLetter();
                updateZoneMusic(); 
                updatePrincessBehavior(delta);
updateKissApproach(delta);if (kissApproach || kissStarted) {
  kissCamTime += delta;
} else {
  kissCamTime = 0;
}

// ‚úÖ FIX: per kiss animacijƒÖ ninja nebesulenda ƒØ ≈æemƒô
if (kissStarted) {
  snapNinjaFeetToGround(0.06); // 0.04‚Äì0.10 pasireguliuok
}



      }

      if (minigameMessageTimer > 0) {
        minigameMessageTimer -= delta;
        if (minigameMessageTimer <= 0 && minigameMessage) {
          minigameMessage.style.display = 'none';
        }
      }

      renderer.render(scene, camera);
    }

    // ---------- judƒójimas / kolizija herojaus ----------
    function isPositionBlocked(x, z) {
      // med≈æiai
      const rTreeSq = HERO_RADIUS * HERO_RADIUS;
      for (const tree of treesData) {
        const dx = x - tree.x;
        const dz = z - tree.z;
        const distSq = dx * dx + dz * dz;
        if (distSq < rTreeSq) return true;
      }

      // D≈æiugas
      if (dziugas) {
        let dx = x - dziugas.position.x;
        let dz = z - dziugas.position.z;
        const rDonkey = HERO_RADIUS + 0.2;
        const rDonkeySq = rDonkey * rDonkey;
        const distSq = dx * dx + dz * dz;
        if (distSq < rDonkeySq) return true;
      }

      // Katinas
      if (cat) {
        let dx = x - cat.position.x;
        let dz = z - cat.position.z;
        const rCat = HERO_RADIUS + 0.1;
        const rCatSq = rCat * rCat;
        const distSq = dx * dx + dz * dz;
        if (distSq < rCatSq) return true;
      }

      // pilies sienos ir centrinis bok≈°tas
      if (isBlockedByCastleWalls(x, z)) return true;
  // bok≈°to (mini games kambario) sienos
  {
    const cx = TOWER_ROOM_CENTER.x;
    const cz = TOWER_ROOM_CENTER.y;
    const r  = TOWER_ROOM_RADIUS;
    const wallThickness = 0.8; // toks pats kaip createTowerRoom
    const pad = wallThickness + HERO_RADIUS * 0.6;

    const frontZ = cz + r;
    const backZ  = cz - r;
    const leftX  = cx - r;
    const rightX = cx + r;

    // priekinƒó siena
    if (Math.abs(z - frontZ) < pad && x > leftX && x < rightX) {
      return true;
    }
    // galinƒó siena
    if (Math.abs(z - backZ) < pad && x > leftX && x < rightX) {
      return true;
    }
    // kairƒó siena
    if (Math.abs(x - leftX) < pad && z > backZ && z < frontZ) {
      return true;
    }
    // de≈°inƒó siena
    if (Math.abs(x - rightX) < pad && z > backZ && z < frontZ) {
      return true;
    }
  }
  // bok≈°to mini-games DUR≈≤ kolizija
  if (doorObjects && doorObjects.length) {
    const doorHalfW = 1.0;   // dur≈≥ plotis /2 (BoxGeometry 2)
    const doorHalfD = 0.25;  // dur≈≥ storis /2 (BoxGeometry 0.4)
    const extraPad  = HERO_RADIUS * 0.5;

    for (let i = 0; i < doorObjects.length; i++) {
      const d = doorObjects[i];
      const dx = x - d.position.x;
      const dz = z - d.position.z;

      if (Math.abs(dx) < doorHalfW + extraPad &&
          Math.abs(dz) < doorHalfD + extraPad) {
        return true; // atsitrenki ƒØ duris
      }
    }
  }

  return false;
}

    // --- PRIDƒñTA: NPC kolizijos helperis (buvo kvieƒçiamas, bet neapra≈°ytas) ---
    function npcIsPositionBlocked(x, z) { // <-- PRIDƒñTA
      // NPC tiesiog naudoja tas paƒçias pilies sien≈≥ kolizijas
      return isBlockedByCastleWalls(x, z);
    }
    // ---------------------------------------------------------------------------
function getGroundYAt(x, z) {
  // pilies akmens platforma yra +0.14
  const dx = x - goalPos.x;
  const dz = z - goalPos.z;
  const r = (CASTLE_RADIUS - 1.0);
  if (dx*dx + dz*dz <= r*r) return 0.14;

  return 0; // visur kitur (mi≈°kas/tiltas) ground = 0
}

function updateMovement(delta) {
  if (!ninja) return;

  // ‚úÖ groundY visada apibrƒó≈ætas
  let groundY = 0;

  // pilies akmeninƒó platforma yra 0.14 auk≈°tyje
  {
    const dx = ninja.position.x - goalPos.x;
    const dz = ninja.position.z - goalPos.z;
    const r = (CASTLE_RADIUS - 1.0);
    if (dx*dx + dz*dz <= r*r) groundY = 0.14;
  }

  // bok≈°to kambarys ir princesƒós bok≈°tas ‚Äì ant 0 (nes floor tavo yra y=0)
  // (jei kada nors j≈≥ floor pakelsi, ƒçia galƒósi pakeist)

  // jei control lock (lai≈°kas / cutscene) ‚Äì neleid≈æiam vaik≈°ƒçiot, tik gravitacija
  if (controlsLocked) {
    velY -= GRAVITY * delta;
    ninja.position.y = Math.max(groundY, ninja.position.y + velY * delta);

    if (ninja.position.y <= groundY) {
      ninja.position.y = groundY;
      velY = 0;
      onGround = true;
      isJumping = false;
    }

  // breakdance laikom pakeltƒÖ + snapinam pƒódas, kad nelƒØst≈≥ ƒØ ≈æemƒô
if (musicOverride === 'breakdance') {
  velY = 0;          // ‚úÖ neleid≈æiam gravitacijai kauptis
  onGround = true;

  ninja.position.y = breakdanceBaseY + BREAKDANCE_RAISE_Y;
  snapNinjaFeetToGround(0.12); // ‚úÖ didesnis clearance
}
return;

  }

  const baseSpeed = 6;
  const runMult = 1.6;
  const rotSpeed = 10;

  let mx = 0, mz = 0;
  if (keys.forward) mz -= 1;
  if (keys.back)    mz += 1;
  if (keys.left)    mx -= 1;
  if (keys.right)   mx += 1;

  const dir = new THREE.Vector3(mx, 0, mz);
  const isMoving = dir.lengthSq() > 0;

  let speed = baseSpeed;
  if (keys.shift && isMoving && actions.run) speed *= runMult;

  let newPos = ninja.position.clone();

  if (isMoving) {
    dir.normalize();

    const targetAngle = Math.atan2(dir.x, dir.z);
    let current = ninja.rotation.y;
    let diff = targetAngle - current;
    diff = (diff + Math.PI) % (Math.PI * 2) - Math.PI;
    const maxStep = rotSpeed * delta;
    if (diff > maxStep) diff = maxStep;
    if (diff < -maxStep) diff = -maxStep;
    ninja.rotation.y = current + diff;

    const move = dir.clone().multiplyScalar(speed * delta);

    let candidate = newPos.clone();
    candidate.x += move.x;
    if (!isPositionBlocked(candidate.x, candidate.z)) newPos.x = candidate.x;

    candidate = newPos.clone();
    candidate.z += move.z;
    if (!isPositionBlocked(candidate.x, candidate.z)) newPos.z = candidate.z;
  }

  velY -= GRAVITY * delta;
  newPos.y += velY * delta;

  if (newPos.y <= groundY) {
    newPos.y = groundY;
    velY = 0;
    if (!onGround) { onGround = true; isJumping = false; }
  } else {
    onGround = false;
  }

  ninja.position.copy(newPos);
}



function updateAnimState() {
  if (!activeAction) return;

  // ‚úÖ jei vyksta breakdance ‚Äì niekas nekeiƒçia
  if (musicOverride === 'breakdance') return;

  // ‚úÖ jei vyksta kiss priƒójimas ar kiss ‚Äì NIEKAS nekeiƒçia animacij≈≥
  if (kissApproach || kissStarted) return;

  // ‚úÖ jei control lock (lai≈°kai/cutscene) ‚Äì irgi nekeiƒçiam animacij≈≥ ƒçia
  if (controlsLocked) return;

  if (isJumping) {
    if (onGround) {
      isJumping = false;
    } else {
      return;
    }
  }

  const isMoving = keys.forward || keys.back || keys.left || keys.right;

  if (isMoving) {
    if (keys.shift && actions.run) fadeToAction('run');
    else if (actions.walk) fadeToAction('walk');
  } else if (actions.idle) {
    fadeToAction('idle');
  }
}


    // kamera
    function updateCamera() {
      // üëë Speciali kamera princesƒós bok≈°te
if (ninja && princess && isHeroInPrincessTower()) {
    // üíã KISS kamera (fiksuota, kad NIEKADA nei≈°eit≈≥ u≈æ sienos)
if (kissApproach || kissStarted) {

  // 1) stabilus midpoint (be jitter)
  const rawMid = new THREE.Vector3()
    .copy(ninja.position)
    .add(princess.position)
    .multiplyScalar(0.5);

  if (!kissCam.initialized) {
    kissCam.mid.copy(rawMid);
    kissCam.pos.copy(camera.position);
    kissCam.initialized = true;
  } else {
    // üîë labai lƒótas mid sekimas ‚Üí dingsta tr≈´kƒçiojimas
    kissCam.mid.lerp(rawMid, 0.04);
  }

  // 2) orbit parametrai
  const R = 4.6;
  const H = 2.9;
  const speed = 0.18; // lƒóƒçiau = romanti≈°kiau + smooth

  const a = kissCamTime * speed + Math.PI * 0.35;

  const desiredPos = new THREE.Vector3(
    kissCam.mid.x + Math.cos(a) * R,
    H,
    kissCam.mid.z + Math.sin(a) * R
  );

  // 3) ≈°velnus kameros judƒójimas (be double-lerp)
  kissCam.pos.lerp(desiredPos, 0.06);
  camera.position.copy(kissCam.pos);

  camera.lookAt(
    kissCam.mid.clone().add(new THREE.Vector3(0, 1.55, 0))
  );

  return;
}




  // 1) Kol princesƒó EINA mar≈°rutu ‚Äî kamera i≈° vir≈°aus, centre
  const princessWalking =
    (princessRoutePhase === 'edgeToCenter' ||
     princessRoutePhase === 'centerToEdge' ||
     princessRoutePhase === 'edgeToNinja');

  if (princessWalking) {
    const center = new THREE.Vector3(PRINCESS_TOWER_CENTER.x, 0, PRINCESS_TOWER_CENTER.y);

    const desiredPos = new THREE.Vector3(center.x, 16, center.z + 0.01); // +0.01 kad lookAt neglitchint≈≥
    camera.position.lerp(desiredPos, 0.08);

    const look = princess.position.clone().add(new THREE.Vector3(0, 1.6, 0));
    camera.lookAt(look);
    return;
  }

  // 2) Kai princesƒó PRIE NINJOS (frozen/done) ‚Äî kamera i≈° ≈°ono
  if (princessFrozen || princessRoutePhase === 'done') {
    const mid = new THREE.Vector3()
      .copy(ninja.position)
      .add(princess.position)
      .multiplyScalar(0.5);

    // ≈°oninƒó kryptis (90¬∞ nuo linijos tarp j≈≥)
    const dir = new THREE.Vector3().subVectors(princess.position, ninja.position);
    dir.y = 0;
    dir.normalize();
    const side = new THREE.Vector3(-dir.z, 0, dir.x); // pasukta 90¬∞

    const desiredPos = mid.clone()
      .addScaledVector(side, 6.0)
      .add(new THREE.Vector3(0, 4.5, 0));

    camera.position.lerp(desiredPos, 0.10);
    camera.lookAt(mid.clone().add(new THREE.Vector3(0, 1.6, 0)));
    return;
  }
}

      if (!ninja) return;

      const dx = ninja.position.x - goalPos.x;
      const dz = ninja.position.z - goalPos.z;
      const distSq = dx * dx + dz * dz;

      let radius = 10;
      let yOffset = 4;

      if (distSq < 40 * 40) {
        radius = 7;
        yOffset = 5;
      }

      if (
        Math.abs(dx) < CASTLE_YARD_HALF_X &&
        Math.abs(dz) < CASTLE_YARD_HALF_Z
      ) {
        radius = 5.5;
        yOffset = 5;
      }

      const vertical = THREE.MathUtils.clamp(camPitch, -0.4, 0.9);

      const planarRadius = radius * Math.cos(vertical);
      const height = yOffset + radius * Math.sin(vertical);

      const offsetX = Math.sin(camYawOffset) * planarRadius;
      const offsetZ = Math.cos(camYawOffset) * planarRadius;

      const desiredPos = new THREE.Vector3(
        ninja.position.x + offsetX,
        ninja.position.y + height,
        ninja.position.z + offsetZ
      );

      camera.position.lerp(desiredPos, 0.15);
      const lookTarget = ninja.position.clone().add(new THREE.Vector3(0, 1.8, 0));
      camera.lookAt(lookTarget);
    }

    // ---------- LAVA ----------
  function isOnSafeGround(pos) {
  // herojaus Y nedomina ‚Äì svarbi tik XY projekcija
  const x = pos.x;
  const z = pos.z;

  // 1) MI≈†KO SALA (startas) ‚Äì visas ratas
  {
    const dx = x - FOREST_CENTER.x;
    const dz = z - FOREST_CENTER.y;
    const r = FOREST_RADIUS - 1.0;
    if (dx * dx + dz * dz <= r * r) return true;
  }

  // 2) PILIES SALA ‚Äì visas akmen≈≥ ratas saugus
  {
    const dx = x - goalPos.x;
    const dz = z - goalPos.z;
    const r = CASTLE_RADIUS - 1.0;
    if (dx * dx + dz * dz <= r * r) return true;
  }

  // 3) BOK≈†TO KAMBARYS (su trim durim) ‚Äì visas ratas
  {
    const dx = x - TOWER_ROOM_CENTER.x;
    const dz = z - TOWER_ROOM_CENTER.y;
    const r = TOWER_ROOM_RADIUS - 1.0;
    if (dx * dx + dz * dz <= r * r) return true;
  }

  // 4) PRINCESƒñS BOK≈†TAS ‚Äì visas ratas
  {
    const dx = x - PRINCESS_TOWER_CENTER.x;
    const dz = z - PRINCESS_TOWER_CENTER.y;
    const r = PRINCESS_TOWER_RADIUS - 1.0;
    if (dx * dx + dz * dz <= r * r) return true;
  }

  // 5) TILTAS ‚Äì trys staƒçiakampiai segmentai (tik lentos)
  const onSegment1 =
    z >= BRIDGE_SEG1_Z - BRIDGE_SEG_DEPTH / 2 &&
    z <= BRIDGE_SEG1_Z + BRIDGE_SEG_DEPTH / 2;
  const onSegment2 =
    z >= BRIDGE_SEG2_Z - BRIDGE_SEG_DEPTH / 2 &&
    z <= BRIDGE_SEG2_Z + BRIDGE_SEG_DEPTH / 2;
  const onSegment3 =
    z >= BRIDGE_SEG3_Z - BRIDGE_SEG_DEPTH / 2 &&
    z <= BRIDGE_SEG3_Z + BRIDGE_SEG_DEPTH / 2;

  const onAnySegment = onSegment1 || onSegment2 || onSegment3;
  const onBridgeX = Math.abs(x - BRIDGE_X) <= BRIDGE_SAFE_HALF_WIDTH;

  if (onAnySegment && onBridgeX) return true;

  // 6) VISUR KITUR ‚Äì LAVA, MIR≈†TI
  return false;
}



 function respawnHero() {
  if (isRespawning || !ninja) return;
  isRespawning = true;
deathLetterShown = false;

  // I≈†KART perkeliam heroj≈≥ atgal ƒØ mi≈°kƒÖ
  ninja.position.set(0, 0, 0);
  
  velY = 0;
  console.log('üíÄ Nukritai ƒØ lavƒÖ ‚Äì respawn mi≈°ke.');

  // pabandom paleisti mirties garsƒÖ
  try {
    audio.deathSound.currentTime = 0;
    audio.deathSound.play();
  } catch (e) {}

  // kai baigiasi death sound ‚Äì paleid≈æiam kiss ir parodom lai≈°kƒÖ
  audio.deathSound.onended = () => {
  if (deathLetterShown) return;
  deathLetterShown = true;

  try {
    audio.respawnKiss.currentTime = 0;
    audio.respawnKiss.play();
  } catch (e) {}

  showLetter(
    'Gerai, grƒØ≈æk pas mane.\n\nDuodu tau buƒçinƒØ ‚Äî ir dar vienƒÖ ≈°ansƒÖ. üòò',
    'Bandysiu dar kartƒÖ!'
  );

  isRespawning = false;
};

}





function checkLavaDeath() {
  if (!ninja) return;
  const p = ninja.position;

  // Mir≈°tam tik tada, kai:
  // 1) nesame saugioj zonoje (lava),
  // 2) esame pakankamai ≈æemai (t. y. prakti≈°kai ant ≈æemƒós / ƒØkritƒô)
  if (!isOnSafeGround(p) && p.y <= 0.05) {
    respawnHero();
  }
}




    function moveNpcTowardsHero(info, delta) {
      if (!info || !info.mesh || !ninja) return false;
      const mesh = info.mesh;

      const dx = ninja.position.x - mesh.position.x;
      const dz = ninja.position.z - mesh.position.z;
      const dist = Math.sqrt(dx * dx + dz * dz);
      const stopDist = 2.0;

      if (dist < stopDist) {
        mesh.rotation.y = Math.atan2(dx, dz);
        return true;
      }

      const speed = 6.0;
      const step = speed * delta;
      const dirX = dx / dist;
      const dirZ = dz / dist;

      // kitos NPC ‚Äì paprasta kolizija
      if (info.name !== 'Lara') {
        const newX = mesh.position.x + dirX * step;
        const newZ = mesh.position.z + dirZ * step;

        if (!npcIsPositionBlocked(newX, newZ)) {
          mesh.position.x = newX;
          mesh.position.z = newZ;
        }

        mesh.rotation.y = Math.atan2(dirX, dirZ);
        return false;
      }

      // ---- LARA ‚Äì slide algoritmas ----
      const fullX = mesh.position.x + dirX * step;
      const fullZ = mesh.position.z + dirZ * step;

      const onlyX = mesh.position.x + dirX * step;
      const onlyZ = mesh.position.z;

      const altX = mesh.position.x;
      const altZ = mesh.position.z + dirZ * step;

      let moved = false;

      if (!npcIsPositionBlocked(fullX, fullZ)) {
        mesh.position.x = fullX;
        mesh.position.z = fullZ;
        moved = true;
      } else {
        if (!npcIsPositionBlocked(onlyX, onlyZ)) {
          mesh.position.x = onlyX;
          moved = true;
        }
        if (!npcIsPositionBlocked(altX, altZ)) {
          mesh.position.z = altZ;
          moved = true;
        }
      }

      if (!moved) return true; // STOP, kad nespamint≈≥ klaid≈≥

      mesh.rotation.y = Math.atan2(dirX, dirZ);
      return false;
    }

    function moveNpcBackToStart(info, delta) {
      if (!info || !info.mesh || !info.startPos) return false;

      const mesh = info.mesh;
      const target = info.startPos;

      const dx = target.x - mesh.position.x;
      const dz = target.z - mesh.position.z;
      const dist = Math.sqrt(dx * dx + dz * dz);

      if (dist < 0.3) {
        mesh.position.copy(target);
        return true;
      }

      const speed = 6.0;
      const step = speed * delta;
      const dirX = dx / dist;
      const dirZ = dz / dist;

      // paprastos NPC
      if (info.name !== 'Lara') {
        const newX = mesh.position.x + dirX * step;
        const newZ = mesh.position.z + dirZ * step;

        if (!npcIsPositionBlocked(newX, newZ)) {
          mesh.position.x = newX;
          mesh.position.z = newZ;
        }

        mesh.rotation.y = Math.atan2(dirX, dirZ);
        return false;
      }

      // ---- LARA slide atgal ----
      const fullX = mesh.position.x + dirX * step;
      const fullZ = mesh.position.z + dirZ * step;

      const onlyX = mesh.position.x + dirX * step;
      const onlyZ = mesh.position.z;

      const altX = mesh.position.x;
      const altZ = mesh.position.z + dirZ * step;

      let moved = false;

      if (!npcIsPositionBlocked(fullX, fullZ)) {
        mesh.position.x = fullX;
        mesh.position.z = fullZ;
        moved = true;
      } else {
        if (!npcIsPositionBlocked(onlyX, onlyZ)) {
          mesh.position.x = onlyX;
          moved = true;
        }
        if (!npcIsPositionBlocked(altX, altZ)) {
          mesh.position.z = altZ;
          moved = true;
        }
      }

      if (!moved) return true; // STOP infinite loop

      mesh.rotation.y = Math.atan2(dirX, dirZ);
      return false;
    }

    // dialogo UI
    function showDialog(questionObj) {
      closeLetter();
      if (!dialogContainer || !dialogTextEl || !dialogOptionsEl) return;
      dialogTextEl.textContent = questionObj.text;

      const btns = dialogOptionsEl.querySelectorAll('button');
      const labels = ['A', 'B', 'C'];
      btns.forEach((btn, i) => {
        const label = labels[i] || '?';
        btn.dataset.choice = label;
        if (questionObj.options && questionObj.options[i]) {
          btn.textContent = questionObj.options[i];
        } else {
          btn.textContent = label;
        }
      });

      dialogContainer.style.display = 'block';
    }

    function hideDialog() {
      if (dialogContainer) dialogContainer.style.display = 'none';
    }

  function handleDialogChoice(choice) {
  if (!npcWaitingForAnswer) return;

  // paimam ≈°io NPC klausimƒÖ
  const q = npcQuestions[npcCurrentIndex] || npcQuestions[0];

  // jei yra teisingas atsakymas ir pasirinkta ne ta raidƒó ‚Äì lieka ta pati mergina
  if (q && q.correct && choice !== q.correct) {
    if (dialogTextEl) {
      dialogTextEl.textContent = '‚ùå Ne, bandyk dar kartƒÖ.';
    }
    // NEu≈ædarom dialogo ir NEmetam NPC ƒØ "leaving" ‚Äì tegul ≈æaidƒójas bando dar
    return;
  }

  // teisingas atsakymas
  npcWaitingForAnswer = false;
  hideDialog();

   const info = npcInfos[npcCurrentIndex];
  if (info) {
    // nutildom balsƒÖ kai pradeda nueidinƒót
    stopNpcVoice(info);

    info.state = 'leaving';
    if (info.talkAction) info.talkAction.stop();
    if (info.idleAction) info.idleAction.play();
  }


  npcDialogTimer = 0.5;
}


    // Teleportai
 function teleportInsideTower() {
  ninja.position.set(TOWER_ROOM_CENTER.x, 0, TOWER_ROOM_CENTER.y + 5);
  snapNinjaFeetToGround(0.04);
  camYawOffset = Math.PI;
  console.log('‚ú® Teleportas ƒØ atskirƒÖ bok≈°to kambarƒØ su trim durim.');

  if (!letterTowerShown) {
    letterTowerShown = true;
    openLetter({
      title: "Princesƒós lai≈°kas",
      body:
`Kiekvienas ≈æingsnis‚Ä¶
ir tu vis arƒçiau manƒôs. ‚ú®

U≈æ ≈°it≈≥ dur≈≥ bus trys bandymai.
ƒÆveik juos visus ‚Äî
ir mes pagaliau susitiksime.

A≈° laukiu ƒçia.
‚Äî Princesƒó`
    });
  }
}

// ‚úÖ atskira funkcija (NE viduje teleportInsideTower)
function teleportToPrincessTower() {
  clearAutoKissTimers();

  // HEROJUS
  ninja.position.set(
    PRINCESS_TOWER_CENTER.x,
    0,
    PRINCESS_TOWER_CENTER.y + (PRINCESS_TOWER_RADIUS - 3.5)
  );
  snapNinjaFeetToGround(0.04);
  camYawOffset = Math.PI;

  // PRINCESƒñ
  if (princess) {
    princess.visible = true;
    princess.position.set(
      PRINCESS_TOWER_CENTER.x,
      0,
      PRINCESS_TOWER_CENTER.y - (PRINCESS_TOWER_RADIUS - 2.5)
    );
    princess.rotation.y = 0;
  }

  // ‚úÖ fiksuojam jos start/kra≈°to pozicijƒÖ
  princessStartPos = princess.position.clone();
  princessEdgePos = princess.position.clone();

  // ‚úÖ bok≈°to centras
  princessCenterPos = new THREE.Vector3(PRINCESS_TOWER_CENTER.x, 0, PRINCESS_TOWER_CENTER.y);

  // ‚úÖ stop prie ninjos (i≈° princesƒós pusƒós)
  {
    const vx = princessEdgePos.x - ninja.position.x;
    const vz = princessEdgePos.z - ninja.position.z;
    const len = Math.sqrt(vx*vx + vz*vz) || 1;
    const stopDist = 2.4;

    princessStopPos = new THREE.Vector3(
      ninja.position.x + (vx/len) * stopDist,
      0,
      ninja.position.z + (vz/len) * stopDist
    );
  }

  princessRoutePhase = 'edgeToCenter';
  princessFrozen = false;
  princessApproachAllowed = true;

  // muzika
  unlockAudioOnce();
  musicOverride = null;
  lastZone = null;
  playMusicCrossfade(music.princess, 0.40, 0.15);

  controlsLocked = true;
  hideNpcSpeech();

  princessScene = 'afterMinigames';
  princessSceneStarted = false;
  princessSceneText =
    'Pagaliau‚Ä¶ tu ƒçia. ‚ù§Ô∏è\n\n' +
    'Bet dar vienas dalykas.\n' +
    'Jei nori mano ≈°irdies ‚Äî parodyk man savo geriausiƒÖ breakdance.\n\n' +
    'Spausk B. üòÑ';
}


    // helperis
  function isHeroInPrincessTower() {
  if (!ninja) return false;
  const dx = ninja.position.x - PRINCESS_TOWER_CENTER.x;
  const dz = ninja.position.z - PRINCESS_TOWER_CENTER.y;
  return dx*dx + dz*dz < (PRINCESS_TOWER_RADIUS - 1.5) ** 2;
}


    function isHeroInCastleYard() {
      const dx = ninja.position.x - goalPos.x;
      const dz = ninja.position.z - goalPos.z;
      return (
        Math.abs(dx) < CASTLE_YARD_HALF_X - 2 &&
        Math.abs(dz) < CASTLE_YARD_HALF_Z - 2
      );
    }
    function checkAfterBridgeLetter() {
      if (!ninja || letterBridgeShown) return;
      if (!dziugasFound) return;

      const dx = ninja.position.x - goalPos.x;
      const dz = ninja.position.z - goalPos.z;
      const distSq = dx * dx + dz * dz;

      // kai patenka ant pilies salos
      const r = (CASTLE_RADIUS + 2);
      if (distSq < r * r) {
        letterBridgeShown = true;
        snapNinjaFeetToGround(0.04);

        showLetter(
          'Tu perƒójai.üñ§\n\nDabar susirask VaivƒÖ ‚Äî katinƒólƒØ prie vart≈≥.\nPasikviesk jƒÖ su P.\nJ≈´s b≈´sit stipri komanda. üòº'
,
          'Einam pas VaivƒÖ!'
        );
      }
    }
function getMinFootWorldY() {
  if (!ninja || !footBones || footBones.length === 0) return null;

  let minY = Infinity;
  for (const b of footBones) {
    b.getWorldPosition(_tmpV3);
    if (_tmpV3.y < minY) minY = _tmpV3.y;
  }
  return isFinite(minY) ? minY : null;
}
function snapNinjaFeetToGround(clearance = 0.02) {
  if (!ninja) return;

  ninja.updateMatrixWorld(true);

  const minFootY = getMinFootWorldY();
  if (minFootY === null) return;

  // ‚úÖ atsi≈ævelgiam ƒØ ZONƒÑ
 const groundY = getGroundYAt(ninja.position.x, ninja.position.z);


let delta = (groundY + clearance) - minFootY;

// ‚úÖ neleisk "nuleisti" herojaus ƒØ ≈æemƒô (ypaƒç breakdance pozoj)
if (delta < 0) delta = 0;

ninja.position.y += delta;
}
function clearAutoKissTimers() {
  if (kissAutoTimer) {
    clearTimeout(kissAutoTimer);
    kissAutoTimer = null;
  }
  if (kissReadyPoll) {
    clearInterval(kissReadyPoll);
    kissReadyPoll = null;
  }
}

function startKissWhenReady() {
  if (kissStarted) return;

  if (kissReady) {
    startKissApproach();
    return;
  }

  // jei kiss animacijos dar neƒØkeltos ‚Äî palaukiam
  if (kissReadyPoll) clearInterval(kissReadyPoll);
  kissReadyPoll = setInterval(() => {
    if (kissStarted) { clearInterval(kissReadyPoll); kissReadyPoll = null; return; }
    if (kissReady) {
      clearInterval(kissReadyPoll);
      kissReadyPoll = null;
      startKissApproach();
    }
  }, 200);
}

function scheduleAutoKiss(ms = 30000) {
  clearAutoKissTimers();

  showPressMHint = true;
  showPressMMessage();

  kissAutoTimer = setTimeout(() => {
    startKissWhenReady();
  }, ms);
}



    // ---- bendras pilies sien≈≥ tikrinimas visiems (herojus, npc, draugai) ----
    function isBlockedByCastleWalls(x, z) {
      const cx = goalPos.x;
      const cz = goalPos.z;

      const frontZ = cz + CASTLE_YARD_HALF_Z;
      const backZ  = cz - CASTLE_YARD_HALF_Z;
      const leftX  = cx - CASTLE_YARD_HALF_X;
      const rightX = cx + CASTLE_YARD_HALF_X;

      const pad = CASTLE_WALL_THICKNESS + HERO_RADIUS * 0.6;

      // priekinƒó siena su vartais
      if (Math.abs(z - frontZ) < pad && x > leftX && x < rightX) {
        const gateHalf = CASTLE_GATE_WIDTH * 0.5;

        // jei vartai U≈ΩDARI ‚Äì visa siena kieta
        if (!castleGateOpen) {
          return true;
        }

        // jei vartai ATVIRI ‚Äì viduryje yra anga, ≈°onai kieti
        if (Math.abs(x - cx) > gateHalf - HERO_RADIUS * 0.2) {
          return true;
        }
      }

      // galinƒó siena
      if (Math.abs(z - backZ) < pad && x > leftX && x < rightX) {
        return true;
      }

      // kairƒó siena
      if (Math.abs(x - leftX) < pad && z > backZ && z < frontZ) {
        return true;
      }

      // de≈°inƒó siena
      if (Math.abs(x - rightX) < pad && z > backZ && z < frontZ) {
        return true;
      }

      // centrinis pilies bok≈°tas ‚Äì ≈°iek tiek ma≈æesnƒó kolizija (galima prieiti arƒçiau)
      const towerPad = 3; // kuo DIDESNIS skaiƒçius ‚Äì tuo arƒçiau gali prieiti prie bok≈°to
      if (
        Math.abs(x - cx) < CASTLE_TOWER_HALF + HERO_RADIUS - towerPad &&
        Math.abs(z - cz) < CASTLE_TOWER_HALF + HERO_RADIUS - towerPad
      ) {
        return true;
      }

      return false;
    }

    function isHeroInTowerRoom() {
      const dx = ninja.position.x - TOWER_ROOM_CENTER.x;
      const dz = ninja.position.z - TOWER_ROOM_CENTER.y;
      return dx * dx + dz * dz < (TOWER_ROOM_RADIUS - 2) ** 2;
    }

    // NPC logika
    function updateNPCLogic(delta) {
      if (!ninja) return;
      if (npcInfos.length === 0) return;
      if (!isHeroInCastleYard()) return;
      if (npcDialogStage === 4) return;

      const totalNPC = npcInfos.length;

      if (!npcDialogSequenceStarted) {
        npcDialogSequenceStarted = true;
        npcCurrentIndex = 0;
        npcDialogStage = 1;
        npcDialogTimer = 0;
        console.log('üëß NPC dialog≈≥ seka prasidƒójo.');
      }

      if (npcWaitingForAnswer) return;

      if (npcDialogTimer > 0) {
        npcDialogTimer -= delta;
        if (npcDialogTimer > 0) return;
      }

      const info = npcInfos[npcCurrentIndex];
      if (!info) return;

      function playIdle(info) {
        if (info.walkAction) info.walkAction.stop();
        if (info.talkAction) info.talkAction.stop();
        if (info.idleAction) info.idleAction.play();
      }
      function playWalk(info) {
        if (info.idleAction) info.idleAction.stop();
        if (info.talkAction) info.talkAction.stop();
        if (info.walkAction) info.walkAction.play();
      }
      function playTalk(info) {
        if (info.idleAction) info.idleAction.stop();
        if (info.walkAction) info.walkAction.stop();
        if (info.talkAction) info.talkAction.reset().play();
      }

      if (info.state === 'idle') {
        info.state = 'movingToHero';
        playWalk(info);
      }

      if (info.state === 'movingToHero') {
  const reached = moveNpcTowardsHero(info, delta);
  if (reached) {
    info.state = 'talking';
    playTalk(info);

    // ---------- NPC KALBƒñJIMO GARSAS ----------
       // NPC kalbƒójimo garsas
    playNpcVoice(info);

    // ------------------------------------------

    const q = npcQuestions[npcCurrentIndex] || npcQuestions[0];
    showDialog(q);
    npcWaitingForAnswer = true;
    return;

  }

      } else if (info.state === 'leaving') {
  playWalk(info);
  const back = moveNpcBackToStart(info, delta);
  if (back) {
    info.state = 'idle';
    playIdle(info);
    npcCurrentIndex++;
    if (npcCurrentIndex >= totalNPC) {
      npcDialogStage = 4;
      teleportInsideTower(); // i≈°kart po 3 klausimo
    } else {
      npcDialogTimer = 0.1; // buvo 1.0 ‚Äì dabar kita mergina beveik i≈°kart pradeda eiti
    }
  }
  
}
    }
        // ---------- DURYS / MINI-GAMES FUNKCIJOS ----------
    function showMinigameMessage(text) {
      if (!minigameMessage) return;
      minigameMessage.textContent = text;
      minigameMessage.style.display = 'block';
      minigameMessageTimer = 3.0;
    }

    function hideAllMinigameOverlays() {
      if (aimOverlay)   aimOverlay.style.display   = 'none';
      if (quizOverlay)  quizOverlay.style.display  = 'none';
      if (cardsOverlay) cardsOverlay.style.display = 'none';
    }
    function faceTargetY(obj, targetPos, extraYaw = 0) {
  const dx = targetPos.x - obj.position.x;
  const dz = targetPos.z - obj.position.z;
  obj.rotation.y = Math.atan2(dx, dz) + extraYaw;
}
function clampToPrincessRoom(mesh, pad = 1.4) {
  const cx = PRINCESS_TOWER_CENTER.x;
  const cz = PRINCESS_TOWER_CENTER.y;
  const dx = mesh.position.x - cx;
  const dz = mesh.position.z - cz;

  const r = PRINCESS_TOWER_RADIUS - pad;
  const d2 = dx*dx + dz*dz;

  if (d2 > r*r) {
    const d = Math.sqrt(d2) || 1;
    mesh.position.x = cx + (dx / d) * r;
    mesh.position.z = cz + (dz / d) * r;
  }
}

function updatePrincessBehavior(delta) {

  // ‚úÖ jei vyksta kiss priƒójimas arba pats kiss ‚Äì princesƒós AI NEBEKI≈†A RANK≈≤
  if (kissApproach || kissStarted) return;

  if (princess && ninja && isHeroInPrincessTower()) {
    faceTargetY(ninja, princess.position);
  }

  if (!princess || !ninja) return;
  if (!princessApproachAllowed) return;


  if (princess && ninja && isHeroInPrincessTower()) {
  faceTargetY(ninja, princess.position);
}

  if (!princess || !ninja) return;
  if (!princessApproachAllowed) return;
if (princessRoutePhase !== window._lastPhase) {
  console.log('Princess phase:', princessRoutePhase, 'stop?', !!princessStopPos);
  window._lastPhase = princessRoutePhase;
}

  const speed = 2.2;
  const snapDist = 0.22;

  // jei jau "frozen" ‚Äì laikom prie ninjos
  if (princessFrozen && princessStopPos) {
    princess.position.x = princessStopPos.x;
    princess.position.z = princessStopPos.z;
    clampToPrincessRoom(princess, 1.4);
    faceTargetY(princess, ninja.position);
    return;
  }

  // jei neturim ta≈°k≈≥ ‚Äì nieko nedarom
  if (!princessStopPos || !princessEdgePos || !princessCenterPos) return;

  // pasirenkam target pagal fazƒô
  let target;
  const doingRoute = (princessScene === 'afterMinigames');

  if (doingRoute) {
    if (princessRoutePhase === 'edgeToCenter') target = princessCenterPos;
    else if (princessRoutePhase === 'centerToEdge') target = princessEdgePos;
    else if (princessRoutePhase === 'edgeToNinja') target = princessStopPos;
    else target = princessStopPos;
  } else {
    // po breakdance ‚Äì tiesiai prie ninjos
    princessRoutePhase = 'done';
    target = princessStopPos;
  }

  // judƒójimas
  const tx = target.x - princess.position.x;
  const tz = target.z - princess.position.z;
  const tdist = Math.sqrt(tx*tx + tz*tz);

  if (tdist <= snapDist) {
    
    // snap ƒØ target
    princess.position.x = target.x;
    princess.position.z = target.z;
    clampToPrincessRoom(princess, 1.4);

    // fazi≈≥ perjungimas
    if (doingRoute) {
      if (princessRoutePhase === 'edgeToCenter') {
        princessRoutePhase = 'centerToEdge';
        return;
      }
      if (princessRoutePhase === 'centerToEdge') {
        princessRoutePhase = 'edgeToNinja';
        return;
      }
      if (princessRoutePhase === 'edgeToNinja') {
        princessRoutePhase = 'done';
      }
    }

    // atƒójo prie ninjos ‚Üí sustabdom + kalbam
    princessActions.walk?.stop();
   
  if (princessActions.talk) {
  princessActions.idle?.stop();

  princessActions.talk.reset();
  princessActions.talk.setLoop(THREE.LoopOnce, 1);   // ‚úÖ vienƒÖ kartƒÖ
  princessActions.talk.clampWhenFinished = true;     // ‚úÖ sustoja paskutinƒój pozoj
  princessActions.talk.play();
}

    faceTargetY(princess, ninja.position);

    princessFrozen = true;

    if ((princessScene === 'afterMinigames' || princessScene === 'afterBreakdance') && !princessSceneStarted) {
      princessSceneStarted = true;

showNpcSpeech(princessSceneText, {
  typeSpeed: 30,
  autoHide: true,
  onDone: () => {
    // ƒçia jau burbulas b≈´na paslƒóptas (autoHide tai padarƒó)
    controlsLocked = false;

    // stabdom voice ƒçia (teisingu momentu)
    if (audio?.princessTalk) {
      audio.princessTalk.pause();
      audio.princessTalk.currentTime = 0;
    }

if (princessScene === 'afterBreakdance') {
  showPressMHint = true;
  showPressMMessage();      // parodo "Paspausk M ‚ù§Ô∏è"
}


  }
});





      playPrincessVoice(1.0);
    }
    return;
  }

  // eina link target
  const step = Math.min(speed * delta, tdist);
  princess.position.x += (tx / tdist) * step;
  princess.position.z += (tz / tdist) * step;
  clampToPrincessRoom(princess, 1.4);

 // eina -> VISADA walk
if (princessActions.walk) {
  princessActions.idle?.stop();
  princessActions.talk?.stop();
  if (!princessActions.walk.isRunning()) princessActions.walk.reset().play();
  princessActions.walk.timeScale = 1.0;
}


  princess.rotation.y = Math.atan2(tx, tz);
}

function startKissApproach() {
  if (!kissReady || !ninja || !princess) return;
  if (kissApproach || kissStarted) return; // ‚úÖ saugiklis nuo loop

  // joki≈≥ "paspausk M" dabar
  showPressMHint = false;
  pendingKissPress = false;
  if (minigameMessage) minigameMessage.style.display = 'none';

  kissApproach = true;
  controlsLocked = true;

  // kad princesƒós AI nebepriklijuot≈≥ prie stopPos
  princessFrozen = false;
  princessRoutePhase = 'done';
  princessApproachAllowed = false; // ‚úÖ kol vyksta kiss priƒójimas, ji pati nebevaik≈°to

  // vektorius tarp j≈≥
  const v = new THREE.Vector3().subVectors(princess.position, ninja.position);
  v.y = 0;
  const dist = v.length() || 1;
  v.multiplyScalar(1 / dist); // unit

  // ≈°onas (kad sustot≈≥ ≈°alia, ne "kaktom")
  const side = new THREE.Vector3(-v.z, 0, v.x);

  // ‚úÖ ma≈æas priƒójimas: abu nueina PO PUSƒò atstumo
  const sideDist = 0.25;  // arƒçiau vienas kito (0.45‚Äì0.7)
  const faceGap  = 0.85;  // minimalus tarpelis

  // ‚úÖ norimas galutinis atstumas tarp j≈≥ (kad nesikirst≈≥)
  const desiredSeparation = 1.7; // 1.1‚Äì1.6, priklausomai nuo modeli≈≥

  // kiek kiekvienas turi paeiti (abu po pusƒô)
  const moveEach = Math.max(0, (dist - desiredSeparation) * 0.5);

  kissNinjaTarget.copy(ninja.position)
    .addScaledVector(v,  moveEach)
    .addScaledVector(side, -sideDist);

  kissPrincessTarget.copy(princess.position)
    .addScaledVector(v, -moveEach)
    .addScaledVector(side, +sideDist);

  // animacijos tik priƒójimui (neb≈´tina, bet gra≈æiau)
  if (actions.walk) fadeToAction('walk', 0.12);

  if (princessActions.walk) {
    princessActions.idle?.stop();
    princessActions.talk?.stop();
    princessActions.walk.reset().play();
    princessActions.walk.timeScale = 1.0;
  }
}


function updateKissApproach(delta) {
  if (!kissApproach || !ninja || !princess) return;

  const speed = 6.0;
  const snap = 0.12;

  // ninja juda ƒØ target
  {
    const dx = kissNinjaTarget.x - ninja.position.x;
    const dz = kissNinjaTarget.z - ninja.position.z;
    const d = Math.sqrt(dx*dx + dz*dz);

    if (d > snap) {
      const step = Math.min(speed * delta, d);
      ninja.position.x += (dx/d) * step;
      ninja.position.z += (dz/d) * step;
      ninja.rotation.y = Math.atan2(dx, dz);
    } else {
      ninja.position.x = kissNinjaTarget.x;
      ninja.position.z = kissNinjaTarget.z;
    }
  }

  // princess juda ƒØ target
  {
    const dx = kissPrincessTarget.x - princess.position.x;
    const dz = kissPrincessTarget.z - princess.position.z;
    const d = Math.sqrt(dx*dx + dz*dz);

    if (d > snap) {
      const step = Math.min(speed * delta, d);
      princess.position.x += (dx/d) * step;
      princess.position.z += (dz/d) * step;
      princess.rotation.y = Math.atan2(dx, dz);
    } else {
      princess.position.x = kissPrincessTarget.x;
      princess.position.z = kissPrincessTarget.z;
    }
  }

  // visada atsisuka vienas ƒØ kitƒÖ
  faceTargetY(ninja, princess.position);
  faceTargetY(princess, ninja.position);

  // patikrinam ar abu jau vietoj
  const nOK = ninja.position.distanceTo(kissNinjaTarget) < 0.15;
  const pOK = princess.position.distanceTo(kissPrincessTarget) < 0.15;

  if (nOK && pOK) {
    kissApproach = false;
    startKissNow();
  }
}

function startKissNow() {
  princessApproachAllowed = false; // laikom i≈°jungtƒÖ per kiss

  console.log('üíã startKissNow()');
  // ‚úÖ ma≈æas "anti-clipping" past≈´mimas (kad rankos ma≈æiau lƒØst≈≥ kiaurai)
 // ‚úÖ labai ma≈æas past≈´mimas (kad nesusikirst≈≥, bet NEatitolint≈≥)
const back = new THREE.Vector3().subVectors(princess.position, ninja.position);
back.y = 0;
back.normalize();

princess.position.addScaledVector(back, 0.02);
ninja.position.addScaledVector(back, -0.01);

  kissStarted = true;
  controlsLocked = true;

  // ‚úÖ 1) Sustabdom VISAS ninja animacijas, kad kiss neb≈´t≈≥ u≈ægo≈ætas
  try {
    if (mixer) mixer.stopAllAction();
  } catch(e) {}

  // ‚úÖ 2) Sustabdom VISAS princess animacijas
  try {
    if (princessActions.walk) princessActions.walk.stop();
    if (princessActions.talk) princessActions.talk.stop();
    if (princessActions.idle) princessActions.idle.stop();
  } catch(e) {}

  // atsisukam vienas ƒØ kitƒÖ
  faceTargetY(ninja, princess.position);
  faceTargetY(princess, ninja.position);

  // ‚úÖ 3) Paleid≈æiam kiss (su pilnu svoriu)
// ‚úÖ 3) Paleid≈æiam kiss (su pilnu svoriu)
if (ninjaKissAction) {
  ninjaKissAction.reset();
  ninjaKissAction.setLoop(THREE.LoopOnce, 1);
  ninjaKissAction.clampWhenFinished = true;
  ninjaKissAction.enabled = true;
  ninjaKissAction.setEffectiveWeight(1);

  // ‚úÖ sulƒótinam iki ~30s
  const d = (ninjaKissClip && ninjaKissClip.duration) ? ninjaKissClip.duration : 4.5;
  const ts = Math.max(0.05, d / KISS_TARGET_SECONDS); // ma≈æesnis = lƒóƒçiau
  ninjaKissAction.setEffectiveTimeScale(ts);

  ninjaKissAction.play();
}

if (princessKissAction) {
  princessKissAction.reset();
  princessKissAction.setLoop(THREE.LoopOnce, 1);
  princessKissAction.clampWhenFinished = true;
  princessKissAction.enabled = true;
  princessKissAction.setEffectiveWeight(1);

  // ‚úÖ sulƒótinam iki ~30s
  const d = (princessKissClip && princessKissClip.duration) ? princessKissClip.duration : 4.5;
  const ts = Math.max(0.05, d / KISS_TARGET_SECONDS);
  princessKissAction.setEffectiveTimeScale(ts);

  princessKissAction.play();
}
  // üé¨ Po kiss pabaigos ‚Äì lƒótas u≈ætemimas + "THE END"
  setTimeout(() => {
    startEndSequence();
  }, (KISS_TARGET_SECONDS * 1000) + 1200); // +1.2s kad tikrai po rank≈≥ nusileidimo

}






   function endCurrentMinigame(success, customMessage) {
  // sustabdom AIM spawn intervalƒÖ
  if (aimSpawnIntervalId) {
    clearInterval(aimSpawnIntervalId);
    aimSpawnIntervalId = null;
  }
  // i≈°valom taikinius
  if (aimTargetsContainer) {
    aimTargetsContainer.innerHTML = '';
  }

  hideAllMinigameOverlays();

  if (activeMinigameDoor !== null && success) {
    miniGamesCompleted[activeMinigameDoor] = true;
  }

  minigameInProgress = false;
  minigameFailed = !success;

  const finishedDoor = activeMinigameDoor;
  activeMinigameDoor = null;

  if (success) {
    const msg = customMessage || '‚úÖ Mini ≈æaidimas ƒØveiktas!';
    showMinigameMessage(msg);
    checkAllMiniGamesDone();
  } else {
    const msg = customMessage || '‚ùå Nepavyko. Bandyk dar kartƒÖ.';

    // parodome lai≈°kƒÖ su mygtuku "Bandyti dar kartƒÖ"
    if (finishedDoor === 0) {
      showLetter(msg, 'Bandyti dar kartƒÖ', () => {
        activeMinigameDoor = 0;
        startAimGame();
      });
    } else if (finishedDoor === 1) {
      showLetter(msg, 'Bandyti dar kartƒÖ', () => {
        activeMinigameDoor = 1;
        startQuizGame();
      });
    } else if (finishedDoor === 2) {
      showLetter(msg, 'Bandyti dar kartƒÖ', () => {
        activeMinigameDoor = 2;
        startCardsGame();
      });
    } else {
      // jeigu dƒól ka≈ækoki≈≥ prie≈æasƒçi≈≥ dur≈≥ indekso nƒóra ‚Äì bent jau parodom ≈æinutƒô apaƒçioje
      showMinigameMessage(msg);
    }
  }
}

function checkAllMiniGamesDone() {
  if (miniGamesCompleted[0] && miniGamesCompleted[1] && miniGamesCompleted[2]) {
    teleportToPrincessTower();
princessFrozen = false;
  }
}
function showPressMMessage() {
  if (!minigameMessage) return;
  minigameMessage.style.display = 'block';
  minigameMessageTimer = 9999; // kad nedingt≈≥
  minigameMessage.innerHTML = `Paspausk <b>M</b> <span style="color:#ff2b6a;">‚ù§Ô∏è</span>`;
}


    // nustatom, prie kuri≈≥ dur≈≥ stovi ≈æaidƒójas
    function checkDoorMinigames() {
      if (!ninja || doorObjects.length === 0) return;

      if (!isHeroInTowerRoom()) {
        currentDoorIndex = -1;
        return;
      }

      let nearest = -1;
      let nearestDistSq = 99999;

      for (let i = 0; i < doorObjects.length; i++) {
        const d = doorObjects[i];
        const dx = ninja.position.x - d.position.x;
        const dz = ninja.position.z - d.position.z;
        const distSq = dx * dx + dz * dz;
        if (distSq < 3 * 3 && distSq < nearestDistSq) {
          nearestDistSq = distSq;
          nearest = i;
        }
      }

      currentDoorIndex = nearest;

      if (!minigameInProgress) {
        if (currentDoorIndex === 0) {
          showMinigameMessage('üö™ 1 durys: AIM ≈æaidimas. Spausk F, kad pradƒótum.');
        } else if (currentDoorIndex === 1) {
          showMinigameMessage('üö™ 2 durys: klausim≈≥ testas apie merginƒÖ. Spausk F.');
        } else if (currentDoorIndex === 2) {
          showMinigameMessage('üö™ 3 durys: kort≈≥ poros. Spausk F.');
        }
      }
    }

      function tryStartMinigame() {
      if (minigameInProgress) return;

      if (!isHeroInTowerRoom()) {
        showMinigameMessage('Turi b≈´ti bok≈°to kambaryje prie dur≈≥.');
        return;
      }
      if (currentDoorIndex < 0 || currentDoorIndex >= doorObjects.length) {
        showMinigameMessage('Prieik arƒçiau vien≈≥ dur≈≥ ir tada spausk F.');
        return;
      }
      if (miniGamesCompleted[currentDoorIndex]) {
        showMinigameMessage('≈†itas mini ≈æaidimas jau ƒØveiktas.');
        return;
      }

      activeMinigameDoor = currentDoorIndex;

      let text = '';
      if (activeMinigameDoor === 0) {
        text = 'Pirmoji u≈æduotis ‚Äì tavo taiklumas. Per trumpƒÖ laikƒÖ turi pataikyti ƒØ kuo daugiau taikini≈≥. Paspausk ‚ÄûPradƒóti ≈æaidimƒÖ‚Äú ir parodyk, koks esi snaiperis!';
      } else if (activeMinigameDoor === 1) {
        text = 'Antroji u≈æduotis ‚Äì atsakyti ƒØ klausimus apie mane. Pa≈æi≈´rƒókim, kaip gerai mane pa≈æƒØsti.';
      } else if (activeMinigameDoor === 2) {
        text = 'Treƒçioji u≈æduotis ‚Äì atsiminti kort≈≥ poras. Susikaupk ir parodyk savo atmintƒØ.';
      }

      showLetter(text, 'Pradƒóti ≈æaidimƒÖ', () => {
        if (activeMinigameDoor === 0) {
          startAimGame();
        } else if (activeMinigameDoor === 1) {
          startQuizGame();
        } else if (activeMinigameDoor === 2) {
          startCardsGame();
        }
      });
    }


    // ---------- 1 MINI-GAME: AIM ----------
    const AIM_TIME_LIMIT = 25; // s
    const AIM_REQUIRED_SCORE = 20;

      function startAimGame() {
      minigameInProgress = true;
      minigameFailed = false;

      aimScore = 0;
      minigameTimer = 0;
      if (aimInfo) {
        aimInfo.textContent = `Ta≈°kai: 0 | Laikas: ${AIM_TIME_LIMIT}s`;
      }
      if (aimTargetsContainer) {
        aimTargetsContainer.innerHTML = '';
      }
      if (aimOverlay) {
        aimOverlay.style.display = 'block';
      }

      if (aimSpawnIntervalId) clearInterval(aimSpawnIntervalId);
      aimSpawnIntervalId = setInterval(spawnAimTarget, 1000);
    }


    function spawnAimTarget() {
      if (!aimTargetsContainer) return;
      if (!minigameInProgress || activeMinigameDoor !== 0) return;

      const box = aimTargetsContainer.getBoundingClientRect();
      const size = 20;

      const el = document.createElement('div');
      el.className = 'aim-target';
      el.style.position = 'absolute';
      el.style.width = `${size}px`;
      el.style.height = `${size}px`;
      el.style.borderRadius = '50%';
      el.style.border = '2px solid #ff5555';
      el.style.boxShadow = '0 0 6px rgba(255,80,80,0.8)';
      el.style.background = 'radial-gradient(circle, #ffaaaa 0%, #aa2222 70%)';
      el.style.cursor = 'crosshair';

      const maxX = box.width - size;
      const maxY = box.height - size;
      el.style.left = `${Math.random() * maxX}px`;
      el.style.top  = `${Math.random() * maxY}px`;

      aimTargetsContainer.appendChild(el);

      // auto dingsta po 1.5s
      setTimeout(() => {
        if (el.parentNode) el.parentNode.removeChild(el);
      }, 900);
    }

    // ---------- 2 MINI-GAME: QUIZ ----------
    const QUIZ_TIME_LIMIT = 120; // s
    const QUIZ_PASS_SCORE = 7;

        function startQuizGame() {
      minigameInProgress = true;
      minigameFailed = false;

      quizIndex = 0;
      quizScore = 0;
      minigameTimer = 0;

      if (quizOverlay) quizOverlay.style.display = 'block';
      renderQuizQuestion();
    }

    function renderQuizQuestion() {
      if (!quizOverlay) return;

      if (quizIndex >= quizQuestions.length) {
        const passed = quizScore >= QUIZ_PASS_SCORE;
        const msg = passed
          ? `‚úÖ Testas ƒØveiktas! Teisingi atsakymai: ${quizScore}/${quizQuestions.length}`
          : `‚ùå Per ma≈æai teising≈≥ atsakym≈≥ (${quizScore}/${quizQuestions.length}).`;
        endCurrentMinigame(passed, msg);
        return;
      }

      const q = quizQuestions[quizIndex];
      if (quizQuestionEl) quizQuestionEl.textContent = q.text;
      if (quizProgressEl) {
        quizProgressEl.textContent =
          `Klausimas ${quizIndex + 1} i≈° ${quizQuestions.length} | Teisingi: ${quizScore}`;
      }

      if (quizOptionsEl) {
        quizOptionsEl.innerHTML = '';
        q.options.forEach((opt, i) => {
          const btn = document.createElement('button');
          btn.dataset.index = String(i);
          btn.textContent = opt;
          btn.style.padding = '6px 10px';
          btn.style.borderRadius = '10px';
          btn.style.border = 'none';
          btn.style.cursor = 'pointer';
          btn.style.background = 'rgba(90,130,255,0.9)';
          btn.style.color = '#fff';
          btn.style.textAlign = 'left';
          quizOptionsEl.appendChild(btn);
        });
      }
    }

    function handleQuizAnswer(idx) {
      if (!minigameInProgress || activeMinigameDoor !== 1) return;

      const q = quizQuestions[quizIndex];
      if (idx === q.correct) {
        quizScore++;
      }
      quizIndex++;
      renderQuizQuestion();
    }

    // ---------- 3 MINI-GAME: KORT≈≤ POROS ----------
    const CARDS_TIME_LIMIT = 40; // s

    function startCardsGame() {
    minigameInProgress = true;
      minigameFailed = false;
      cards = [];
      firstCardIndex = null;
      secondCardIndex = null;
      matchedPairs = 0;
      minigameTimer = 0;

      const values = [];
      for (let v = 1; v <= 8; v++) {
        values.push(v, v);
      }

      // shuffle
      for (let i = values.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [values[i], values[j]] = [values[j], values[i]];
      }

      values.forEach(v => {
        cards.push({ value: v, matched: false, flipped: false });
      });

      if (cardsOverlay) cardsOverlay.style.display = 'block';
      if (cardsInfoEl) cardsInfoEl.textContent = 'Atverk poras per laikƒÖ.';

      renderCardsGrid();
    }

    function renderCardsGrid() {
      if (!cardsGridEl) return;
      cardsGridEl.innerHTML = '';

      cards.forEach((card, i) => {
        const btn = document.createElement('button');
        btn.dataset.cardIndex = String(i);
        btn.style.height = '48px';
        btn.style.borderRadius = '8px';
        btn.style.border = 'none';
        btn.style.cursor = 'pointer';
        btn.style.fontWeight = '700';

        if (card.matched) {
          btn.textContent = String(card.value);
          btn.style.background = 'rgba(90,220,120,0.9)';
          btn.style.color = '#021';
        } else if (card.flipped) {
          btn.textContent = String(card.value);
          btn.style.background = 'rgba(230,230,255,0.9)';
          btn.style.color = '#000';
        } else {
          btn.textContent = '‚ùì';
          btn.style.background = 'rgba(40,60,120,0.9)';
          btn.style.color = '#fff';
        }

        cardsGridEl.appendChild(btn);
      });
    }

    function handleCardClick(idx) {
      if (!minigameInProgress || activeMinigameDoor !== 2) return;
      if (idx < 0 || idx >= cards.length) return;

      const card = cards[idx];
      if (card.matched || card.flipped) return;

      if (firstCardIndex === null) {
        firstCardIndex = idx;
        card.flipped = true;
        renderCardsGrid();
        return;
      }

      if (secondCardIndex === null) {
        secondCardIndex = idx;
        card.flipped = true;
        renderCardsGrid();

        setTimeout(() => {
          const c1 = cards[firstCardIndex];
          const c2 = cards[secondCardIndex];

          if (c1.value === c2.value) {
            c1.matched = true;
            c2.matched = true;
            matchedPairs++;
            if (matchedPairs === cards.length / 2) {
              endCurrentMinigame(true, '‚úÖ Visos poros surastos!');
              return;
            }
          } else {
            c1.flipped = false;
            c2.flipped = false;
          }

          firstCardIndex = null;
          secondCardIndex = null;
          renderCardsGrid();
        }, 600);
      }
    }

    // bendras mini-games timeris
    function updateMinigameTimer(delta) {
      if (!minigameInProgress || activeMinigameDoor === null) return;

      minigameTimer += delta;

            if (activeMinigameDoor === 0) {
        const left = Math.max(0, Math.ceil(AIM_TIME_LIMIT - minigameTimer));
        if (aimInfo) {
          aimInfo.textContent = `Ta≈°kai: ${aimScore} | Liko: ${left}s`;
        }
        if (minigameTimer >= AIM_TIME_LIMIT) {
          const passed = aimScore >= AIM_REQUIRED_SCORE;
          if (passed) {
            endCurrentMinigame(
              true,
              `‚úÖ Puikiai! Nu≈°ovei ${aimScore} taikini≈≥.`
            );
          } else {
            const diff = Math.max(0, AIM_REQUIRED_SCORE - aimScore);
            const msg = `≈†ƒØ kartƒÖ pritr≈´ko ${diff} ta≈°k≈≥ iki pergalƒós. Bandyk dar kartƒÖ!`;
            endCurrentMinigame(false, msg);
          }
        }

      } else if (activeMinigameDoor === 1) {
        if (minigameTimer >= QUIZ_TIME_LIMIT) {
          const passed = quizScore >= QUIZ_PASS_SCORE;
          endCurrentMinigame(
            passed,
            passed
              ? `‚úÖ Spƒójai per laikƒÖ! (${quizScore}/${quizQuestions.length})`
              : `‚ùå Laikas baigƒósi. Teisingi: ${quizScore}/${quizQuestions.length}.`
          );
        }
      } else if (activeMinigameDoor === 2) {
        const left = Math.max(0, Math.ceil(CARDS_TIME_LIMIT - minigameTimer));
        if (cardsInfoEl) {
          cardsInfoEl.textContent = `Atverk poras. Liko: ${left}s`;
        }
        if (minigameTimer >= CARDS_TIME_LIMIT) {
          endCurrentMinigame(false, '‚ùå Laikas baigƒósi, vis≈≥ por≈≥ nespƒójai.');
        }
      }
    }


    // ---------- MINIMAPAS ----------
    function drawMinimap() {
      if (!ninja) return;

      const ctx = mapCtx;
      const w = minimapCanvas.width;
      const h = minimapCanvas.height;

      ctx.clearRect(0, 0, w, h);

      ctx.fillStyle = 'rgba(5, 10, 20, 0.9)';
      ctx.fillRect(0, 0, w, h);

      ctx.save();
      ctx.translate(w / 2, h / 2);

      const scale = (w * 0.9) / (MAP_VIEW_RADIUS * 2);

      // Mi≈°ko sala
      ctx.fillStyle = '#193b19';
      ctx.beginPath();
      ctx.arc(
        (FOREST_CENTER.x - ninja.position.x) * scale,
        (FOREST_CENTER.y - ninja.position.z) * scale,
        FOREST_RADIUS * scale,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // Pilies sala
      ctx.fillStyle = '#777777';
      ctx.beginPath();
      ctx.arc(
        (goalPos.x - ninja.position.x) * scale,
        (goalPos.z - ninja.position.z) * scale,
        CASTLE_RADIUS * scale,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // Bok≈°to kambarys
      ctx.fillStyle = '#999999';
      ctx.beginPath();
      ctx.arc(
        (TOWER_ROOM_CENTER.x - ninja.position.x) * scale,
        (TOWER_ROOM_CENTER.y - ninja.position.z) * scale,
        4,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // Princesƒós bok≈°tas
      ctx.fillStyle = '#ff66aa';
      ctx.beginPath();
      ctx.arc(
        (PRINCESS_TOWER_CENTER.x - ninja.position.x) * scale,
        (PRINCESS_TOWER_CENTER.y - ninja.position.z) * scale,
        4,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // Med≈æiai
      ctx.fillStyle = '#1c4a2a';
      for (const tree of treesData) {
        const dx = tree.x - ninja.position.x;
        const dz = tree.z - ninja.position.z;
        if (Math.abs(dx) > MAP_VIEW_RADIUS || Math.abs(dz) > MAP_VIEW_RADIUS) continue;
        const mx = dx * scale;
        const mz = dz * scale;
        ctx.beginPath();
        ctx.arc(mx, mz, 2, 0, Math.PI * 2);
        ctx.fill();
      }

      // D≈æiugas
      if (dziugas) {
        const dx = dziugas.position.x - ninja.position.x;
        const dz = dziugas.position.z - ninja.position.z;
        if (Math.abs(dx) <= MAP_VIEW_RADIUS && Math.abs(dz) <= MAP_VIEW_RADIUS) {
          const mx = dx * scale;
          const mz = dz * scale;
          ctx.fillStyle = dziugasFound ? '#00c8ff' : '#4aa3ff';
          ctx.beginPath();
          ctx.arc(mx, mz, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Katinas
      if (cat) {
        const dx = cat.position.x - ninja.position.x;
        const dz = cat.position.z - ninja.position.z;
        if (Math.abs(dx) <= MAP_VIEW_RADIUS && Math.abs(dz) <= MAP_VIEW_RADIUS) {
          const mx = dx * scale;
          const mz = dz * scale;
          ctx.fillStyle = catFollowing ? '#ff99ff' : '#ffccff';
          ctx.beginPath();
          ctx.arc(mx, mz, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Pilies centras markeris
      ctx.fillStyle = '#ff4444';
      const gx = (goalPos.x - ninja.position.x) * scale;
      const gz = (goalPos.z - ninja.position.z) * scale;
      if (Math.abs(gx) < w / 2 && Math.abs(gz) < h / 2) {
        ctx.beginPath();
        ctx.arc(gx, gz, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      // Herojaus rodyklƒó
      ctx.save();
      ctx.rotate(-ninja.rotation.y + Math.PI);
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.moveTo(0, -6);
      ctx.lineTo(4, 6);
      ctx.lineTo(-4, 6);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      ctx.restore();

      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.strokeRect(4, 4, w - 8, h - 8);
    }
  </script>
</body>
</html>
